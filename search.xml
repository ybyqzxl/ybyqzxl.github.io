<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[每日算法（两数之和、两数相加）-11.12]]></title>
      <url>%2F2018%2F11%2F12%2F%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%89%2F</url>
      <content type="text"><![CDATA[今天开始记录每天学习一道两道的算法题，由简入难。今天一共学习了两道算法，一道简单一道中等，分别为两数之和、两数相加，下面开始记录题以及自己的分析。 两数之和 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。123给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 分析：刚拿到题发现并不是很难，于是很快写出如下算法：12345678910111213public int[] sumInArray(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; int val = target - nums[i]; for (int j = i; j &lt; nums.length; j++) &#123; if (nums[j] == val) &#123; return new int[] &#123; i, j &#125;; &#125; else &#123; continue; &#125; &#125; &#125; return null; &#125; 但是该方法的时间复杂度为$O(n^2)$；通过查看解析，发现使用哈希表进行处理，通过以空间换取速度的方式，可以将查找时间从 $O(n)$ 降低到 $O(1)$，但是如果出现冲突，查找时间还是可能会退化到 $O(n)$。方法如下：1234567891011public static int[] sumInArray(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int val = target - nums[i]; if (map.containsKey(val)) &#123; return new int[]&#123;map.get(val), i&#125;; &#125; map.put(nums[i], i); &#125; return null; &#125; 该方法遍历了一次，因此时间复杂度为$O(n)$，但是作为代价就是空间复杂度为$O(n)$。 两数相加 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。除了数字 0 之外，这两个数字都不会以零开头。123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析：首先拿到题目很困惑，因为很长时间没有做链表之类的题目，首先自己想到的是如果其中一个链表开头为0，则直接返回另一个链表，然后在循环进行遍历逐位相加，但是手写代码发现写不出来😓，因此去查看官方解析： 类似于纸上计算两个数字的和，首先从最低有效位也就是列表L1 和 L2 的表头开始相加。由于每位数字都应当处于 0…9 的范围内，因此两个数字的和时可能会出现“溢出”。例如，5 + 7 = 12。在这种情况下，将当前位的数值设置为 22，并将进位 carry=1 带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。 参考代码如下：123456789101112131415161718192021222324252627282930public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode p = l1; ListNode q = l2; ListNode currentNode = head; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; currentNode.next = new ListNode(sum % 10); currentNode = currentNode.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; currentNode.next = new ListNode(carry); &#125; return head.next; &#125;public class ListNode &#123; int val; ListNode next; ListNode(int value) &#123; val = value; &#125; &#125; 今天学习了两个算法，再次记录自己的学习状态，以敦促自己继续去学习]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android面试知识点总结]]></title>
      <url>%2F2017%2F09%2F14%2FAndroid%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[仅用作与记录自己看到的知识点总结，图片来源于网络 blog。 1. Activity 与 Fragment 的生命周期？Activity： 启动 Activiy：onCreate-&gt;onStart()-&gt;onResume(),Activity 进入运行状态. Activity 退居后台(Home 或启动新Activity):onPause()-&gt;onStop(). Activity 返回前台:onRestart()-&gt;onStart()-&gt;onResume(). Activity 后台期间内存不足情况下当再次启动会重新执行启动流程。 锁屏:onPause()-&gt;onStop(). 解锁:onStart()-&gt;onResume().Fragment: 创建 Fragment:onAttach()-&gt;onCreate-&gt;onCreateView()-&gt;onActivityCreate()-&gt;onStart()-&gt;onResume() 销毁 Fragment:onPause()-&gt;onStop()-&gt;onDestroyView()-&gt;onDestroy()-&gt;onDetach(). 从返回栈中回到上一个 Fragment:onDestroyView()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume().Activity 和 Fragment 关系： 2. Activity 的四种启动模式和特点？ standard(标准模式):每次启动都会创建一个新的实例，并放入栈顶。（无法使用非 Activity 类的 Context 启动该模式的 Activity，如果启动需要加上 FlAG_ACTIVITY_NEW_TASK标记创建一个栈）。 singleTop(栈顶复用模式):如果启动的 Activity 在栈顶，则该 Activity 不会重建，同时 Activity 的 onNewIntent() 方法会被调用，如果不在栈顶则通 standar 模式。 singleTask(栈内复用模式):若启动的 Activity 在栈内，则不会创建新的实例调用 onNewIntent() 方法，并将该 Activity 上面所以的 Activity 清空（如果其他应用启动该 Activity，若不存在则简历新的 Task，若存在在后台，则后台 Task 也切换到前台）。 singleInstance(单例模式):新的 Activity 直接创建新的任务栈，当该模式的 Activity 存在于某个栈中，后面任何激活该 Activity 都会重用该实例。 3. Activity 的缓存方法？Activity 由于异常终止时，系统会调用 onSaveInstanceState()来保存 Activity 状态(onStop()之前和onPause()没有既定的时序关系)。当重建时，会调用 onRestoreInstanceState()，并且把 Activity 销毁时 onSaveInstanceState()方法所保存的 Bundle 对象参数同时传递给 onSaveInstanceState()和onCreate()方法。因此，可通过 onRestoreInstanceState()方法来恢复 Activity 的状态，该方法的调用时机是在 onStart()之后。onCreate()和 onRestoreInstanceState()的区别：onRestoreInstanceState()回调则表明其中Bundle对象非空，不用加非空判断。onCreate()需要非空判断。建议使用onRestoreInstanceState(). 4. Service 的生命周期及两种启动方法。 startService 启动服务: 用于启动一个服务执行后台任务，停止服务使用 stopService(). bindService 启动服务: 启动服务进行通信，停止服务使用 unbindService(). startService/stopServiceonCreate()-&gt;onStartCommand()-&gt;onDestroy()第一次调用会触发 onCreate()和 onStartCommand，之后每次启动服务只触发 onStartCommand()无论 startService 多少次，stopService 一次就会停止服务 bindService/unbindServiceonCreate-&gt;onBind()-&gt;onUnbind()-&gt;onDestroy()第一次 bindService 会触发 onCreate 和 onBind，以后每次 bindService 都不会触发任何回调bindService 启动的生命周期依附于启动它的 Context 5. Service 保活。 在 onStartCommond()中将返回值设置为 START_STICKY 在 onDestroy()中重启 service 黑色保活：不同 app 进程利用广播相互唤起。 白色保活：启动前台 service 灰色保活：利用系统漏洞启动前台 service。 6. 广播的两种注册方法，有什么区别。 动态注册：通过调用 Context.registerReceiver 进行注册，跟随组件的生命周期，特定时刻监听广播。 静态注册：在 AndroidMainfest.xml 中声明，程序关闭后仍会调用，常驻广播，时刻监听广播。 7. Intent的使用方法及所传递的数据类型。 显示 Intent：按名指定要启动的组件 隐示 Intent：不指定特定组件，声明要执行的常规操作，从而允许其他应用中组件来处理。 Intent 可传递的数据类型：基本类型及其数组数据，String/CharSequence类型的数据及其数组数据，也可以传递Parcelable和Serializable类型的数据，以及它们的数组/列表数据。 8. ContentProvider使用方法。进行跨进程通信，实现进程间得数据交互和共享。通过 Context 中 getContentResolver()获得实例，通过 Uri 匹配进行数据的增删改查。ContentProvider 使用表的形式来组织数据，无论数据的来源是什么，ContentProvider 都会认为是一种表，然后把数据组织成表格 9. Thread、AsyncTask、IntentService的使用场景与特点。 Thread线程，独立运行与于 Activity 的，当 Activity 被 finish 后，如果没有主动停止 Thread 或者 run 方法没有执行完，其会一直执行下去。 AsyncTask 封装了两个线程池和一个 Handler，（SerialExecutor用于排队，THREAD_POOL_EXECUTOR为真正的执行任务，Handler 将工作线程切换到主线程），其必须在 UI 线程中创建，execute 方法必须在 UI 线程中执行，一个任务实例只允许执行一次，执行多次将抛出异常，用于网络请求或者简单数据处理。 IntentService：处理异步请求，实现多线程，在 onHandleIntent 中处理耗时操作，多个耗时任务会依次执行，执行完毕后自动结束。 10. 五种布局: FrameLayout、LinearLayout、 AbsoluteLayout、RelativeLayout、TableLayout 各自特点及绘制效率对比。 FrameLayout: Android 中最简单布局，所有控件默认出现在左上角，可以使用 layout_margin，layout_gravity 等属性控制子控件的相对布局位置。 LinearLayout: 一行或者一列布局空间，可使用 orientation=horizontal|vertical 来控制布局方式。 AbsoluteLayout: 自定义空间的x，y 来调整位置。 RelativeLayout: 相对布局，通过相关属性来定义空间的位置 android:layout_centerInParent=”true|false”android:layout_centerHorizontal=”true|false”android:layout_alignParentRight=”true|false” TableLayout: 将字元素的位置以表格形式进行布局。 11. Android的数据存储形式。 SQLite 数据库存储 文件存储 SharedPreference 存储 网络存储 12. SQlite 的基本操作Android 提供了 SQLiteOpenHelper 类，通过该类可以简单控制数据库的创建和升级。 onCreate(): 创建数据库 onUpgrade(): 升级数据库 两个方法必须重写，然后实现创建和升级数据库的逻辑。 getReadableDatabase()和 getWritableDatabase(): 创建或打开一个现有数据库，返回一个可对数据库进行读写操作的对象，当数据库不可写入的时候getReadableDatabase()以只读的方式返回数据库对象，getWritableDatabase()返回异常。 insert(): 插入数据 update(): 更新数据 delete(): 删除数据 query(): 查询数据 13. Android中的MVC模式。 Model（模型） View（视图） Controler（控制器） View 传送指令到 Controller，其完成逻辑后通知 Model 改变状态，Model 将新数据更新到 View。所有通信都为单向。接受指令时，一是通过 View 接受指令并传递给 Controller；另一种是直接通过 Controller 接受指令。 14. Merge、ViewStub 的作用。 Merge: 减少视图层级，可以删除多余的层级，优化 UI。 ViewStub: 按需加载，减少内存使用量、加快渲染速度。不支持 merge 标签 15. Json有什么优劣势。优点 轻量级的数据交换格式 读写更加容易 易于机器的解析和生成 缺点 语义性较差，不如 xml 直观 16. 动画有哪两类，各有什么特点？ 传统动画：帧动画和补间动画。 属性动画。区别 属性动画才是真正的实现了view的移动，补间动画对view的移动更像是在不同地方绘制了一个影子，实际的对象还是处于原来的地方。 当动画的repeatCount设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity无法释放而导致内存泄漏，而补间动画却没有问题。 xml 文件实现的补间动画，复用率极高。在Activity切换，窗口弹出时等情景中有着很好的效果。 使用帧动画时需要注意，不要使用过多特别大的图，容易导致内存不足。 17. Handler、Loop消息队列模型，各部分的作用。Android消息机制包含: MessageQuene、Handler、Looper、Message. Message: 需要春娣的消息，可以传递数据。 MessageQuene: 消息队列，通过单链表数据结构来维护消息列表，（投递和删除消息）。 Handler: 消息辅助类，向消息池发送各种消息事件 Handler.sendMessage 发送消息Handler.handleMessage 处理消息 Looper: 不断从消息队里中读取消息，按分发机制将消息分发给目标处理者。MessageQuene、Handler 和 looper 三者之间的关系：每个线程中只能存在一个Looper，保存在ThreadLocal中。主线程（UI线程）已经创建了一个Looper，所以在主线程中不需要再创建Looper，其他线程中需要创建Looper。每个线程中可以有多个Handler，即一个 Looper 可以处理来自多个 Handler 的消息。 Looper 中维护一个 MessageQueue，来维护消息队列，消息队列中的 Message 可以来自不同的 Handler。 当调用 handler.sendMessage()发送 message 时，实际上发送到与当前线程绑定的 MessageQuene 中，然后当前线程绑定的 Looper 不断从 MessageQueue 取出新的 Message，调用 msg.target.disspatchMessage(msg) 方法将消息分发到与 Message 绑定的 handler.handleMessage()中。 18. 怎样退出终止App。 创建一个集合类对所有活动进行管理，ActivityCollector，通过 list 来管理 Activity。 killProcess(android.os.Process.myPid())杀死当前程序进程。 19. Asset目录与res目录的区别。 assets：不会在 R 文件中生成相应标记，存放到这里的资源在打包时会打入程序安装包中。（通过 AssetManager 类访问这些文件） res：会在 R 文件中生成 id 标记，资源在打包时如果使用到则打包到安装包中，未使用到不会打入安装包中。 res/anim:存放动画资源res/raw：和 asset 下文件一样打包时直接打入程序安装包中（会映射到 R 文件中） Tables assets res/raw res/drawable 获取资源方式 文件路径+文件名 R.raw.xxx R.drawable.xxx 是否被压缩 NO NO YES(失真压缩) 能否获取子目录下的资源 YES NO NO 20. Android怎么加速启动Activity。 onCreate()中不执行耗时操作 把页面显示的View细分一下，放在AsyncTask里逐步显示，用handler更好。这样用户的看到的就是有层次有步骤的一个个的view的展示，不会是先看到一个黑屏，然后一下显示所有view。 最好做成动画，效果更自然。 利用多线程的目的就是尽可能的减少onCreate和onReume的时间，使得用户能尽快看到页面，操作页面。 减少主线程阻塞时间 提高 Adapter 和 AdapterView 的效率 优化布局文件 21. Android性能优化方法 布局优化：尽量减少布局文件的层级 删除布局中无用的控件和层次，有选择的使用性能较低的 ViewGroup 采用标签，ViewStub，布局重用可降低布局的层级（ViewStub提供了按需加载的功能，当需要时才会将 ViewStub 中布局加载到内存，提高了初始化效率） 避免过度绘制 绘制优化：View 的 onDraw 方法避免执行大量操作。 onDraw 中不要创建新的布局对象。 onDraw 中不做耗时任务，大量循环十分抢占 cpu 时间片，造成 View 的绘制不流畅。 内存泄漏优化 避免写出内存泄漏代码 通过分析工具（MAT、LeakCannary）找出潜在的内存泄漏方法，然后解决。 导致内存泄漏的原因: 集合类的泄漏 单例/静态变量造成内存泄漏 匿名内部类/非静态内部类造成内存泄漏 资源未关闭 响应速度的优化：避免在主线程做耗时的操作。 ListView/RecyclerView优化： 使用 viewHolder 模式来提高效率 异步加载：耗时操作放在异步线程 滑动时停止加载和分页加载 线程优化：采用线程池，避免程序中存在大量 Thread 。 其他性能优化： 不要过多的创建对象。 不要过多使用枚举类，枚举占用内存空间要比整型大。 常量使用 static final 修饰。 使用 Android 特有的数据结构。 适当采用软引用和弱引用。 采用内存缓存和磁盘缓存。 尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。 22. Android中软引用与弱引用的应用场景。Java 引用类型分类：在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。 软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。 如果只是想避免 OOM 异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。 23. Bitmap 压缩策略 加载 Bitmap 的方式： BitmapFactory 四类方法： decodeFile(文件系统) decodeResourece(资源) decodeStream(输入流) decodeByteArray(字节数) BitmapFactory.opeions 参数 inSampleSize 采样率，对图片高和宽进行缩放，以最小比进行缩放（一般取值为2的指数）。通常是根据图片宽高实际的大小/需要的宽高大小，分别计算出宽和高的缩放比。但应该取其中最小的缩放比，避免缩放图片太小，到达指定控件中不能铺满，需要拉伸从而导致模糊。 inJustDecodeBounds 获取图片的宽高信息，交给 inSampleSize 参数选择缩放比。通过inJustDecodeBounds=true，然后加载图片就可以实现只解析图片的宽高信息，并不会真正的加载图片，所以这个操作是轻量级的。当获取了宽高信息，计算出缩放比后，然后在将inJustDecodeBounds=false,再重新加载图片，就可以加载缩放后的图片。 高效加载 Bitmap 的流程 将 BitmapFactory.Options 的 inJustDecodeBounds 参数设为 true 并加载图片 从 BitmapFactory.Options 中取出图片原始的宽高信息，对应于 outWidth 和 outHeight 参数 根据采样率规则并结合目标 view 的大小计算出采样率 inSampleSize 将 BitmapFactory.Options 的 inJustDecodeBounds 设置为 false 重新加载图片 24. 自定义View过程：onMeasure()、onLayout()、onDraw() onMeasure()方法：单一 View，一般重写此方法，针对 wrap_content 情况，规定 View 默认的大小值，避免于 match_parent 情况一致。ViewGroup，若不重写，就会执行和单子View 中相同逻辑，不会测量子 View。一般会重写 onMeasure()方法，循环测量子View。 onLayout()方法:单一 View，不需要实现该方法。ViewGroup 必须实现，该方法是个抽象方法，实现该方法，来对子 View 进行布局。 onDraw()方法：无论单一View，或者ViewGroup都需要实现该方法，因其是个空方法. 25. 事件分发机制事件分发机制详解 26. Android长连接，怎么处理心跳机制。 长连接：长连接是建立连接之后, 不主动断开. 双方互相发送数据, 发完了也不主动断开连接, 之后有需要发送的数据就继续通过这个连接发送. 心跳包：其实主要是为了防止NAT超时，客户端隔一段时间就主动发一个数据，探测连接是否断开 服务器处理心跳包：假如客户端心跳间隔是固定的, 那么服务器在连接闲置超过这个时间还没收到心跳时, 可以认为对方掉线, 关闭连接. 如果客户端心跳会动态改变, 应当设置一个最大值, 超过这个最大值才认为对方掉线. 还有一种情况就是服务器通过TCP连接主动给客户端发消息出现写超时, 可以直接认为对方掉线. Android微信智能心跳方案 27. Zygote的启动过程在Android系统里面，zygote是一个进程的名字。Android是基于Linux System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。 28. Android IPC:Binder原理。 IPC:不同进程之间彼此是不能共享的，而内核空间却是可共享的。Client进程向Server进程通信，利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。 Binder原理:Binder通信采用C/S架构，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。架构图如下所示： Binder 四个角色： Client进程：使用服务的进程 server 进程：提供服务的进程 ServiceManager 进程：将字符型是的 Binder 名字转为 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 名字获取到 Server 中 Binder 实体的引用。 Binder 驱动：进程间 Binder 通信的建立，Binder 在进程间的传递，Binder 引用计数管理，数据包在进程间传递和交互等一系列底层支持。Binder 运行机制： 注册服务：Server 在 ServiceManager 注册服务 获取服务：Client 从 ServiceManager 获取相应的 Service 使用服务：Client 根据得到的 Service 信息建立与 Service 所在的 Server 进程通信的通路可与 Server 进行交互。 29. Android 5.0，6.0，7.0 8.0新特性。 5.0: Material Design 支持多种设备 全新通知中心 支持64位 ART 虚拟机 电池续航改进 全新“最近应用程序” 安全性改进 不同数据独立保存 改进搜索 支持蓝牙4.1、USB Audio、多人分享等 6.0： 动态权限管理 系统层支持指纹识别 APP 关联 Android Pay 电源管理 TF 卡默认存储 7.0： 分屏多任务 下拉快捷开关 新通知消息 夜间模式 流量保护模式 全新设置样式 改进 Doze 休眠机制 系统级电话黑名单 菜单键快速切换应用 8.0： 画中画 通知标志 自动填充框架 系统优化 后台限制 等等优化很多Android 8.0 致谢：Android 校招面试指南Android 开发工程师面试指南特别感谢：stormzhang，关注张哥以来分享的东西对自己帮助很大。 stormzhang博客 公众号 知识星球]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运用约束性统计机器翻译进行 Aspect-Level 的跨语言情感分类]]></title>
      <url>%2F2017%2F03%2F20%2F%E8%BF%90%E7%94%A8%E7%BA%A6%E6%9D%9F%E6%80%A7%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E8%BF%9B%E8%A1%8C-Aspect-Level-%E7%9A%84%E8%B7%A8%E8%AF%AD%E8%A8%80%E6%83%85%E6%84%9F%E5%88%86%E7%B1%BB-5%2F</url>
      <content type="text"><![CDATA[本文是对 Aspect-Level Cross-lingual Sentiment Classiﬁcation with Constrained SMT 论文的 的一些笔记及理解，方便自己理解以及其他人的参考。 如有其他人看到我的博客的内容后请在留言处留下自己的意见和对我所理解的错误的指正，谢谢！ 由于自己英语能力有限，其中一部分词语可能理解有误，希望指正！ 传统的情感分析方法主要是基于： 基于机器学习的方法：通过对特征进行提取标记的监督学习方法。 基于词汇的方法：通过意见短语或词汇的关联规则。 而大多的情感分类方法主要分为三种资源和文本： 训练：用于训练分类器的资源（搜集的训练示例和词汇）。测试：用来分析情感意见的资源。输出：输出的分类结果。 传统的跨语言情感分类方法是基于 文档 或 句子 的粗粒度层面，由于不涉及到特殊的标记所以很容易进行语言翻译，而在 Aspect 层面标记依赖于一系列带特征标记的意见单元，在翻译到另一种语言时需要映射两种语言之间的意见单元，而在 aspect 层面由于标签依赖于标记的一组特定意见单元有关，当被转移到另一种语言时，需要映射两种语言之间的意见单元。 因此提出一种保留意见单元边界的翻译方法，这样避免了转换后需要进行源语言和目标语言之间的意见单元映射（词对齐）。该方法主要有两种用例：用例1：用训练语言训练 LTRAIN 的分类器对测试语言 LTEST 进行情感极性测试，得出的 LOUT是测试语言的情感极性。由（1）表示。$$L_{TRAIN} \neq L_{TEST}; L_{OUT} = L_{TEST} (1)$$通常有两种方法：a. 将可用训练资源翻译到测试语言中去然后构建分类器，并用测试语言进行测试得出结果.b. 将测试语言翻译到目标语言中并得出结果，并将得到的意见单元翻译回源语言，并将结果映射到测试集上去。 SA为情感分析，T 为翻译，Proj 为映射，Learn 为学习。 用例2：用训练语言训练分类器，但是我们需要对不同的语言进行分析结果，因此公式（2）成立。$$ L_{OUT} \neq L_{TEST}（2）$$通常有两种方法：c. 在测试语言中分析测试语言的的情感极性，并且把结果翻译到期望的语言中去，即：$$L_{TRAIN} = L_{TEST}$$d. 测试语言首先被翻译到期望语言中，并且用期望语言的情感分析方法进行测试，即：$$L_{TRAIN} = L_{OUT}$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于 Aspect 的情感分析]]></title>
      <url>%2F2017%2F03%2F06%2F%E5%9F%BA%E4%BA%8E-Aspect-%E7%9A%84%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[写本文的目的在于记录自己在阅读 Bing Liu 的 Sentiment Analysis and Opinion Mining 的一些笔记以及对文章中所写信息的理解，方便自己理解以及其他人的参考。 本篇内容主要是自己对该书第五章的内容 Aspect-based Sentiment Analysis 的理解，如有其他人看到我的博客的内容后请在留言处留下自己的意见和对我所理解的错误的指正，谢谢！ 由于自己英语能力有限，其中一大部分词语可能理解有误，希望指正！ 基本概念在传统的文档或句子级别的情感分析方面，在分析是主要有五部分组成，分别是 ( ei, aij, sijkl, hk, tl ). ei : 一个实体或目标的名称; aij : 为该实体的一个方面 (诺基亚电池不错，电池为该方面) ; sijkl : 值对实体某个方面的意见，如上面所举的例子，不错为对诺基亚电池的意见; hk : 为发表意见的人或者部门 (holder) ; tl : 为发表该意见的时间; 为了获取这五部分需要进行六个任务，在任务之前需要解释一下所用到的概念： 实体模型 ( Model of entity ): 一个实体或目标 ei 是有一组 aspects 的集合组成 A = { ai1, ai2, &hellip;, ain }. ei 可以由其实体表达式的任一的有限集合来表示 { eei1, eei2, &hellip;, eeis }. 每个实体中的 aspects aij ∈ Ai 可以被其 aspect (方面) 表达式的任一有限集合来表示 { aeij1, aeij2, &hellip;, aeijm }. 文本意见模型 ( Model of opinion document ): 一个意见文档 d 包含在某一个时间点上意见持有者集合 { h1, h2, &hellip;, hp} 对实体集合 { e1, e2, &hellip;, ei } 的一些方面 ( aspects ) 所发表的意见。 所以，给定一个意见文档D，意见分析包含以下6个任务： Task 1 实体提取与分类 ( Entity extraction and categorization): 提取D中的所有实体表达式，并将同义实体表达式分类或分组到实体集群（或类别）中。 每个实体表达式集合指示唯一实体 ei ; Task 2 方面(属性)提取与分类 ( aspect extraction and categorization): 提取实体的所有方面 ( aspect ) 表达式，并将这些方面表达式分类到集中。 实体 ei 的每个方面表达式集表示唯一的方面 aij ; Task 3 意见持有者(发布者)提取与分类 ( opinion holder extraction and categorization): 从文本或结构化数据中提取意见持有人的意见，并对其进行分类; Task 4 时间提取与分类 ( time extraction and categorization): 提取意见的时间，标准化不同的时间格式; Task 5 对属性情绪分类 ( aspect sentiment classification ): 确定关于方面 aij 的意见是正面的，负面的还是中性的，或者将方面的数字情感评级分配; Task 6 五元意见组的生成 ( opinion quintuple genertation ): 基于上述任务的结果生成在文档d中表达的所有意见五元组 ( ei, aij, sijkl, hk, tl ) ; 通常把基于该框架的意见分析叫做基于 aspect 的情感分析 ( aspect-based sentiment analysis )。 Aspect-level这里主要集中讨论上述六个任务中的方面(属性)提取与分类 ( aspect extraction and categorization) 任务： 方面提取 ( Aspect extraction ): 例如 “The voice quality of this phone is amazing,” 其中 ”voice quality“ 是 ”This phone“ 的方面，但是 ”This phone“ 并不指明是一个 GENRAL 的方面，因为在这里他只是代表了电话的 voice quality. 但是 ”I love this phone“ 指明了电话代表了一个全体。所以 GENRAL 方面为 ”This phone“. 记住每当我们谈论一个方面时，我们必须知道它属于哪个实体。 方面分类 ( Asepect Sentiment classfication ): 这个任务决定了不同方面的观点是积极，消极还是中立。 在上面的第一个例子中，对 “voice quality” 方面的意见是积极的。 在第二个例子中，对 GENERAL 方面的意见也是积极的。 方面情感分类( Aspect Sentiment Classification )在进行分类时主要有两种方法： 基于监督学习的方法 基于词典的方法 基于监督学习的方法：当前的主要进行的方法是分析确定依赖关系，比如: ( Jiang et al..2011 ) 将一组方面的相关特征进行分类 ( Boiy and Moens, 2009 ) 基于解析树中对目标的方面特征的位置进行加权分析 基于监督学习的方法依赖于训练数据，这表明从一个领域标记的训练数据训练出来的模型在另一个领域中表现很差。并且当前的方法研究也主要应用于文档级别，因为文档级别较长，并且包含比单个句子更多的分类特征。因此，监督学习难以扩展到大量的应用领域。 基于词典的方法：该方法可以避免一些基于监督学习所遇到的问题，并且已经证明在大量领域表现不错。这样的方法通常为无监督的，通过应用情感词典 ( sentiment lexicon ) , 复合表达 ( composite expressions ) , 意见规则 ( role of opinion ) 和 句子解析树来确定句子中每个方面的情感趋向。同时也考虑了情感转意 ( sentiment shifters ) , 转折词 ( but-clauses ) 等。 下面介绍一个简单的基于词典的方法分类方法，假设实体和方面已知，其主要有四个步骤： 标记情感词和情感短语 ( Mark Sentiment words and phrases ) : 标记句子中的情感词和短语，每个积极的情感给情感分数+1，每个校级的情感给情感分数-1，例如：”The voice quality of this phone is not good, but the battery life is long.“ 通过分析时候，该句子变成 ”The voice quality of this phone is not good [+1], but the battery life is long“ 因为 ”good“ 是一个积极的词语，但是注意 “long” 并不是一个情感词，并且也不指明情感的积极和消极态度，但是联系上下文可知 ”long“ 可以代表一个情感词。 应用情感转意 ( Apply sentiment shifters ) 情感转义 ( Sentiment shifters ) 是词或者短语，它可以改变情感的方向，这里有很多转换，例如有可能转换语义的消极词语：*not, never, none, nobody, nowhere, neither, cannot*，通过该分析，由于句子中存在 ”not“ 所以该句子变成 ”The voice quality of this phone is not **good* [-1], but the *battery life\* is long“* 注意，并不是所有这些词语会让情感转变，比如 ”not only… but also.“ 遇到这些词需要我们注意。 处理转折词(Handle but-clauses) : 表示相反的词或短语需要特殊处理，因为它们也经常改变情绪的方向，在英语中最常使用的反向词为 ”but“ 。 通过应用以下规则来处理包含相反词或短语的句子：如果不能确定一方的意见，则在相反词之前的情感方向和相反词之后的情绪方向彼此相反。使用如果不能确定是因为转折词或短语并不总只是指意见的变化，比如： ”Car-x is great, but Car-y is better.“ 。上述例句因为有转折词 “but” 所以通过这一处理之后上述例句变为： ”The voice quality of this phone is not good [-1], but the battery life is long [+1]“ 。我们可以推断 “long” 对 ”battery life“ 是积极地情感。除了 ”but“ 之外，短语比如: ”with the expection of“, “expect that”, “expect for” 对这些短语的处理方式也是相同的。但是在否定的情况下不是所有的都代表着相反，比如： ” not only… but also. “ 所以处理这些词或短语要预先标识。 总的意见 ( Aggregate opinions ) : 通过意见聚合函数将收集到的情感分数进行处理，从而确定句子中的每个方面上的情感最终取向。其主要步骤为下：&emsp;&emsp;S : 表示一个包含一个方面 ( aspect )集合 { ai1, ai2, &hellip;, ain } 和包含一些情感词或短语的集合 { sw1, sw2, &hellip;, swn } 并且这些情感词或短语通过1-3的步骤得出情感分数的句子。所以意见聚合公式可以表示为：$$score(a_1,s)=\sum_{ow_j∈s}\frac{sw_j.so}{dist(sw_j,a_i)}$$&emsp;&emsp;swj : 是句子中的情感词或短语。&emsp;&emsp;dist( swj, ai) : 是方面ai 与情感词 swj 在 s 中的距离。&emsp;&emsp;dist( swj, ai) : 是方面ai 与情感词 swj.so 为 swi 的情感词分数。 如果最终得分是正的，那么对方面 ai 的意见是肯定的。如果最终得分为负，则情绪为负，否则为中性。这种方法在很多情况下表现良好。 同时，现在有很多其他意见聚合函数方法，比如： ( Hu and Liu, 2004 ) 简单地总结句子或句子段中的所有情绪词的情绪分数。 ( Kim and Hovy, 2004 ) 使用词的情绪分数相乘的办法。 意见基本规则和语义的组成 ( Basic Rules of Opinions and Compositional Semantics )意见规则表达了一种暗示正面或负面情绪的概念。它可以是简单的个人情绪词与他们的隐含情绪或复合表达式，可能需要常识或领域知识来确定他们的方向。下面将描述这些规则。表示这些规则的一种方式是使用组合语义 ( compositional semantics ) 的概念，其中陈述了复合表达式的含义是其组成部分的含义和它们组合的语法规则的函数。下面，我们首先在概念层次上描述规则，而不考虑它们如何在实际句子中表达，因为许多这些规则可以以多种方式表达，并且也可以是和上下文相关的。之后，我们转到表达式层次，讨论在情感分析的上下文中关于组成语义的当前研究，其目的是组合多个输入成分表达式以导出复合表达式的整体情绪方向。规则使用类似于 BNF 形式的方式表示，其规则表如下： 1. POSITIVE &emsp;&emsp; ::= P2. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| PO3. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| sentiment_shifter N4. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| sentiment_shifter NE5. NEGATIVE&emsp;&emsp;::= N6. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| NE7. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| sentiment_shifter P8. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| sentiment_shifter PO P 和 PO 为两种积极的情感表达式，其中： P 为原子表达式，即为句子或短语。 PO 为多个表达式组成的表达式。 N 和 NE 为两种消极的情感表达式，其中： N 为原子表达式，即为句子或短语。 NE 为多个表达式组成的表达式。 “sentiment_shifter P” 和 ”sentiment_shifter PO“* 代表的消极的积极态度。即为消极态度。 “sentiment_shifter N” 和 ”sentiment_shifter NE“* 代表的消极的消极态度。即为积极态度。 需要注意的是，这些不是以实际的BNF形式表示，而是用伪语言表示的抽象概念。我们很难精确的指出这些情感，因为在情感转意 ( sentimet_shifters ) 中会转到不同的情感方向，最后的 POSITIVE 和 NEGATIVE 表示最后的分析结果。 情感转意( sentimet_shifters ): 消极词语例如：*not, never, none, nobody, nowhere, neither, cannot* 是最常见的情感转意词语，同时情态动词 ( Modal auxiliary verbs ) 例如 *would, should, could, might, must, ought* 是一种转意词语，例如：”The brake could be improved,“ 可以转意情感，但并不是所有的是这样。有一些前缀词语也是一方面。一些典型的副词例如 ”barely“, “hardly”\ 通过比较 ”It works“ 和 “It hardly works” 可知两个反面意见是不同的。同时想一些 ”fail“, “omit”, “neglect” 同样具有转意功能。讽刺句\ *( sarcasm )\* 也会改变句子的情感方向。虽然手动识别这样的转意不是困难的，但是通过自动化系统识别它们并在实际句子中正确地处理它们是具有挑战性的。 现在定义不包含转意的 N, NE, P, PO 基于他们的特性将这些表达式分组成六个概念类别： 情感词或短语 ( Sentiment word and phrase ) : 这是最简单的也是最常用的类别，其中情绪词或短语单独可以暗示方面 ( aspect ) 的正面或负面意见，例如 “The voice quality is good” 中的 “good” 。这些词语或短语被称为为 P 和 N. 9. P &emsp;&emsp; ::= a_positive_sentiment_word_or_phrase10. N &emsp;&emsp; ::= a_negative_sentiment_word_or_phrase 积极或消极意见项目的减少或增加 ( Decreased and increased quantity of an opinionated item (N and P) ) : 表示减少或增加与意见项目（通常名词和名词短语）相关联的数量可以改变情感的方向。比如: ”This drug reduced my pain significantly“. ”drug” 是一个消极的词语，而 ”reduced pain“ 则表示减少疼痛是一个积极的方向。 11. PO &emsp;&emsp; ::= less_or_decreased N12. N &emsp;&emsp;&emsp;::= more_or_increased P13. NE &emsp;&emsp; ::= less_or_decreased P14. N &emsp;&emsp;&emsp;::= more_or_increased N 在潜在的消极或积极条目中增加或减少 ( High, low, increased and decreased quantity of a positive or negative potential item ) : 例如：“The battery life is short” 和 “The battery life is long.” 这些方面比如 ”battery life“ 的 态度是积极的，我们称他们为 PPI *( positive potential items )*. 同理，例如: “This phone costs a lot” 和 “Sony reduced the price of the camera.” 其中 ”Cost“ 和 ”price“ 的态度是消极的，我们称他们为 NPI *( negative potential items )* 诸如 ”battery“, ”cost“, “price” 本身并没有情感方向，但是增加量词之后就有了方向，其可表示为下面中的规则。 15. PO &emsp;&emsp; ::= no_low_less_or_decreased_quantity_of NPI16. &emsp;&emsp;&emsp;&emsp; | large_larger_or_increased_quantity_of PPI17. NE &emsp;&emsp; ::= no_low_less_or_decreased_quantity_of PPI18. &emsp;&emsp;&emsp;&emsp; | large_larger_or_increased_quantity_of NPI19. NPI &emsp;&emsp; ::= a_negative_potential_item20. PPI &emsp;&emsp;::= a_positive_potential_item 可取或不可取的事实( Desirable or undesirable fact ) : 客观表达式可能意味着积极或消极的情绪，因为他们可以描述可取和不可取的事实。例如：”After my wife and I slept on the mattress for two weeks, I saw a mountain in the middle”. 该句话清楚地隐含了对 ”mattress“ 的消极情绪，但是 ”mountain“ 并没有携带任何意见，因此遵循下面两个规则: 21. P &emsp;&emsp; ::= desirable_fact22. N &emsp;&emsp;::= a_positive_potential_item 与规范或期望值范围的偏差( Deviation from the norm or a desired value range ) : 在一些应用程序领域中，项目的值具有期望的范围或范数，如果该值偏离正常范围，则为消极的，例如: “After taking the drug, my blood pressure went to 410.” 通常这样句子为客观的，所以定义如下规则。 23. P &emsp;&emsp; ::= within the_desired_value_range24. N &emsp;&emsp;::= deviate_from the_desired_value_range 生产、消耗、浪费资源或废物 ( Produce and consume resource and waste ) : 如果实体产生大量的资源，则是期望的（积极的），若是消耗大量资源，则是不被期望的（消极的），同理如果生产大量废物则是不被期望的（消极的），同理如果消耗大量废物则是期望的（积极的），所以定义如下规则。 25. P &emsp;&emsp; ::= produce a_large_quantity_of_or_more resource26. &emsp;&emsp;&emsp; | produce no,_little_or_less waste27. &emsp;&emsp;&emsp; | consume no,_little_or_less resource28. &emsp;&emsp;&emsp; | consume a_large_quantity_of_or_more waste29. N &emsp;&emsp; ::= produce no,_little_or_less resource30. &emsp;&emsp;&emsp; | produce some_or_more waste31. &emsp;&emsp;&emsp; | consume a_large_quantity_of_or_more resource32. &emsp;&emsp;&emsp; | consume no,_little_or_less waste 这些概念规则可以在实际句子中使用不同的单词和短语出现在许多（看似无限数量）的形式中，并且在不同的领域中，它们也可以以不同的方式表现。因此，他们很难认识。没有认识他们，规则不能应用。 现在研究最多的组成规则是与情绪逆转 ( sentimet reversal ) 有关，通常有情感转意和消极积极词语组成，比如: ”NOT“ &amp; POS(“good”) => NEG(“not good”)，另一方面就是遵循11到14的规则，比如：”reduced“ &amp; NEG(“PAIN”) => POS(“reduced pain”)。还有就是情感冲突( sentiment conflict ), 当多个情感词汇出现在一起时，例如 “terribly good” 冲突解决是通过基于分配给它们的相对权重对成分进行排序来实现的，这些相对权重指示哪些成分对于情绪更重要。10年，引入了六种类型的组合规则，他们是情绪反转 (sentiment reversal)，聚集 (aggregation)，传播 (propagation), 控制 (domination), 中和 (neutralization), 集中 (intensification)。其分别表示如下： 情绪反转 (sentiment reversal): 和之前说明的规则类似。 聚集 (aggregation): 与情绪冲突(sentiment conflict)相似，但是定义不同，如果形容词-名词，副词-形容词，副词-动词短语中的术语的情感具有相反的方向，则将具有预修饰符的主导极性的混合极性分配给短语。比如，POS(“beautiful”) &amp; NEG(“fight”) => POSneg(“beautiful fight”)。 传播 (propagation): 当在短语/子句中使用 “propagation” 或 “transfer” 类型的动词时，应用传播规则，并且需要确定具有之前方面的极性。比如，PROP-POS(“to admire”) &amp; “his behavior” => POS(“his behavior”); “Mr.X” &amp; TRANS(“supports”) &amp; NEG(“crime business”) => NEG(“Mr.X”)。 控制 (domination): (1) 如果子句中的动词和客观的极性具有相反的方向，则动词的极性占优势，比如，NEG(“to deceive”) &amp; POS(“hopes”) => NEG(“to deceive hopes”).(2) 如果一个复合句使用 but 连接，则 but 后面的子句的态势特征是占主导地位，比如，”NEG(“It was hard to climb a mountain all night long”), but POS(“a magnificent view rewarded the traveler at the morning”).“ => POS(whole sentence)). 中和 (neutralization): 当介词修饰符或条件运算符与情绪语句相关时，应用中和规则，比如，“despite” &amp; NEG(‘worries’) => NEUT(“despite worries”). 集中 (intensification): 加强或者削弱情感分数，比如，Pos_score(“happy”) \&lt; Pos_score(“extremely happy”)). 方面提取( Aspect Extraction )该任务可以看做是一个信息提取任务，但是，在情感分析的上下文中，一些问题的具体特征可以方便进行提取。这个关键特征就目标的意见，而目标通常是从句子中提取的方面或者主题。因此，重要的任务是从句子识别目标并且识别其表达的意见。但是意见分为显示意见和隐示意见，显示意见的提取主要有以下四个方面： 基于频繁名词和名词短语的提取 利用意见和目标关系提取 利用监督学习提取 利用主题模型提取 由于方面提取主要形式是在线评论，其有两种文本格式，如下： My SLR is on the shelf by camerafun4 Aug 09’04 Pros: Great photos, easy to use, very small Cons: Battery usage; included memory is stingy. I had never used a digital camera prior to purchasing this Canon A70. I have always used a SLR … Read the full review Figure 5.1. An example of a review of format 1. GREAT Camera., Jun3,2004 Reviewer: jprice174 from Atlanta, Ga Aug 09’04 Pros: Great photos, easy to use, very small Cons: Battery usage; included memory is stingy. I did a lot of research last year before I bought this camera… It kinda hurt to leave behind my beloved nikon 35mm SLR, but I was going to Italy, and I needed something smaller, and digital. The pictures coming out of this camera are amazing. The ‘auto’ feature takes great pictures most of the time. And with digital, you’re not wasting film if the picture doesn’t come out. … Figure 5.2. An example of a review of format 2. 查找频繁名词和名词短语该方法从给定领域中的大量评论中找到作为名词和名词短语的显式方面表达式。其方法有： (Hu and Liu, 2004) 使用数据挖掘算法，用磁性 (POS) 标识器识别名词和名词短语（或组）。 该方法的主要思想是：记录他们出现的频率，并且仅保留频繁的频率，其中频率阈值可以通过实验确定。使用这种方法的原因是，当人们评论一个实体的不同方面时，他们使用的词汇通常收敛。因此，经常谈论的那些名词通常是真实和重要的方面。但是评论中的不相关内容通常是多样的，即，在不同的评论中它们是非常不同的。因此，这些不频繁的名词可能是非方面或较不重要的方面。虽然这种方法很简单，但实际上是相当有效的。 这种算法的精度被(Popescu and Etzioni,2005)提高了，他们的算法试图去除那些可能不是实体方面的名词短语，它通过计算短语和与实体类相关联的一些关系区分器 (mernoymy discriminators) 例如（camera）之间的点向互信息（PMI）得分来评估每个发现的名词短语。通过搜索网络用于找到 camera 的组件或部分得出的 camera 的名关系区分器为 “of camera”, “camera has”, “camera comes with” 等。其 PMI 的简化公式为：$$PMI(a,d)=\frac{hits(a ∩ d)}{hits(a)hits(d)}$$其中: a 为使用频率识别出来的候选的方面 (aspect) d 为一个鉴别器 使用方面 (aspect) 识别资源在许多应用中，资源使用是重要的方面，例如，“This washer uses a lot of water.”。在这里，对 ”water“ 的使用量是 ”washer“ 的一个方面，并且这句话指示消极意见，因为消耗太多的资源是不期望的。但是这句话中没有意见，因此，发现资源词和短语（其被称为资源术语）对于情感分析是重要的。如下，显示了之前提出的两个涉及资源的意见规则： P&emsp;&emsp;&emsp; | consume no,_little_or_less resource N&emsp;&emsp;&emsp; | consume a_large_quantity_of_or_more resource 在（Zhang和Liu，2011a）中，提出了一种提取资源项的方法。 例如，在上述示例中，应当提取 “water” 作为资源项。该方法基于二分图拟定了问题，并提出了一种迭代算法来解决这个问题。 该算法基于以下观察提出： 在句子中表达的关于资源使用的情绪或观点通常由以下三元组确定，{动词(verb), 量词(quantifier), 名词或名词词组(noun_term)}. 例如：”This washer uses a lot of water“, 中 ”uses“ 是动词，”a lot of“, 是量词，”water“, 为名词代表着资源。 该方法使用这样的三元组来帮助识别域语料库中的资源。该模型使用基于二分图循环定义来反映的资源使用动词（例如，consume）和资源术语（例如，water）之间的特殊强化关系。量词不用于计算，而是用于识别候选动词和资源术语。该算法假定给出了一个量不多并且可以手动编译的量化器列表。基于循环定义，使用类似于 HITS 的迭代算法来解决问题。为了开始迭代计算，使用一些全局种子资源来寻找和得出使用资源较强的动词的得分。然后将这些分数应用为用于任何应用域的迭代计算的初始化。当算法收敛时，就识别出了候选资源项的排序列表。 意见词典扩展和方面提取由于情绪/观点与其目标（或方面）之间的关系，情感词可以通过所识别的方面来识别，并且方面可以通过已知的情绪词来识别。提取的情感词和方面被用于识别新的情感词和新的方面，其被再次用于提取更多的情感词和方面。由于该过程涉及通过情感词和方面的传播，该方法被称为双重传播(double propagation)。这些提取规则基于基于情感词和方面之间的某些特定依赖关系。采用依赖语法来描述关系。同时也强加了一些限制，情感词也可被认为是形容词和方面名词或名词短语。情感词和方面之间的依赖关系包括 mod, pnmod, subj, s, obj, obj2和desc, 而情感词和方面本身只包含连接关系conj。 OA-Rel 表示情感词和方面之间的关系，情感词本身之间的联系 OO-Rel 和方面之间的联系 AA-Rel,而每个 OA-Rel，OO-Rel或AA-Rel中的关系是&lt; POS(wi), R,POS(wj)&gt;的三元组, 其中POS(wi)是词wi的POS标签，R是依赖关系。该提取过程是基于规则的方法，比如：”Canon G3 produces great pictures,” 形容词 “great” 通过 mod 解析认为依赖于名词 “picture” 这种形式形成 OA-Rel. 类似于这样，如果我们知道 “great” 是一个情感词，并且给出一个规则 “一个情感词通过 mod 依赖于一个名词，则名词可以作为一个方面”，通过这个规则可以直接提取 “picture” 作为一个方面 (aspect). 同理，我们知道 “picture” 是一个方面，则可以利用类似的规则提取 “great” 作为情感词。通过这种方式有以下四个任务： 利用情感词提取方面 利用方面提取方面 利用提取的方面提取情感词 使用给定和提取的意见词提取情感词其中 OA-Rels 被用来给任务 1 和 3，AA-Rels 被用作任务 2 ，OO-Rels 被用作任务 4。这四个子任务分别定义了四类型规则,如下图表中所示： 表中 o 或者 a 为要提取的情感词或方面 (aspect)，{O} 或者 {A} 是给定或提取的已知的情绪词或方面的集合。H 代表任意单词，POS(O(or A))和 O(or A)-Dep 代表着 POS 标签和单词 O(or A) 的依赖关系。{JJ} 和 {NN} 分别是潜在的情感词和方面的 POS 标签集合。{JJ} 包含 JJ, JJR, JJS; {NN} 包含 NN 和 NNS; {MR} 由依赖关系组成，包含{mod, pnmod, subj, s, obj, obj2, desc}; {CONJ} 只包含 conj, 箭头表示依赖，例如：O → O-Dep → A 代表 O 通过关系 O- Dep 依赖于 A. 具体来说，R1i 为使用情感词 (O) 来提取方面 (a)，R2i 为使用方面 (A) 来提取情感词 (O)，R3i 为使用提取出来的方面集合 (Ai) 来提取方面 (a)，R4i 为使用提取出来的情感词集合 (Oi) 来提取情感词 (o). 该表中的方法最初是为英语设计，但是也适用于中文在线文本讨论，这种方法也可以仅使用一个情感词典来查找方面。 总结该文章为通过自己翻译 基于 Aspect 的情感分析 的这一章的部分内容理解而总结，也是自己对看过内容之后的记录，谢谢！]]></content>
    </entry>

    
  
  
</search>
