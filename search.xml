<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[HTTP的原理及工作机制]]></title>
      <url>%2F2019%2F12%2F17%2FHTTP%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[HTTP 定义最直观的印象： 浏览器输入地址，打开网页 Android 发送网络请求，返回对应内容 实质：用于传输超文本的协议：超文本传输协议（HyperText Transfer Protocol）。 工作方式客户端发送请求，服务器收到请求后将响应发送给客户端。 URL -&gt; HTTP 报文 示例：http://zhaoxueli.win/text?name=panda http: 协议类型zhaoxueli.win：服务器地址text?name=panda：路径 path 对应报文格式-Request 示例： 1234GET /text?name=panda HTTP/1.1 //表示请求行对应：请求方式（method） 路径（path） HTTP版本（HTTP version）Host:zhaoxueli.win //服务器地址Content-Type:text/plainContent-Length:243 Response 报文示例: 12345678HTTP/1.1 200 OK //表示状态行：HTTP版本（HTTP version） 状态码（status code） 状态信息（status message）content-type: application/json;charset=utf-8cache-control: public, max-age=60, s-maxage=60vary: Accept,Accept-Encodingetag: W/&quot;0233445533ddfasfaf&quot;content-encoding: gzip[&#123;&quot;user&quot;:&quot;aaaa&quot;&#125;] //body 关键内容 Request Methods 请求方法 GET:获取资源，无 Body–执行多次与执行一次相同（幂等性） POST:增加或修改资源，有 Body PUT:只修改资源：有 Body–执行多次与执行一次相同（幂等性） DELETE:删除资源：无 Body–执行多次与执行一次相同（幂等性） HEAD:同 GET 方法，区别是使用 HEAD 方法时不返回 Body，一般用于下载，请求头信息。 Response Status Code:响应状态码，对响应结果做出类型化描述（比如：请求成功） 1XX: 临时性消息（101：支持Http2，100：）兼容消息 2XX: 成功 3XX: 重定向（301：永久迁移，302：暂时迁移，304：内容无改变） 4XX: 客户端错误（浏览器） 5XX: 服务器内部错误 Header ：HTTP 消息的元数据（metadata）[数据的属性]，常见如下： Host：服务器主机地址（不是用来寻址，寻找路径） Content-Type/Content-Length: Body 的类型和长度 Content-Length: 内容的长度（字节） Content-Type: 内容的类型 text/html: 表示 html application/json: 表示 Json 信息，用于 web api 的响应 POST/GET 请求 application/x-www-form-urlencoded: 普通表单，encoded URL 格式 multipart/form-data: 多部分形式，一般用于传输包含二进制内容的多项内容（带文件的表单），包含 boundary 字段：表示分界线，分界 body 和 header，或者 header 与 header image/jpeg，application/zip：单文件 Chunked Transfer Encoding: 分块传输编码 Transfer-Encoidng: chunked， 表示 Body 长度无法确定，Content-Length 不能使用 Body 格式： \ \ \ \ 0 \n (最后传输 0 + “\n”表示内容结束) Location: 重定向的模板 URL User-Agent: 用户代理（客户端，标识请求设备类型） Range / Accept-Range: 指定 Body 的内容范围—分段加载【断点续传】 Cookie / set-Cookie: 发送 Cookie / 设置 Cookie Authorization: 授权信息 Accept: 客户端能接受的数据类型，如 text/html Accept-Charset: 客户端接受的字符集，如 UTF-8 Accept-Encoding: 客户端接受的压缩编码类型，如 gzip Content-Encoding：压缩类型，如 gzip Cache Cache 和 Buffer 的区别：Cacahe 表示缓存，存储起来可以直接取；Buffer 表示缓冲，针对工作流 Cache-Control: no-cache[在此访问页面时，先请求服务是否失效],no-store[无缓存],max-age[指定时间内不用请求服务器，直接使用] Last-Modified: if-Modified-Since-最近修改时间，指定时间内不需要请求资源 Etag：if-None-Match：指纹标签是否相同，相同则使用，否则重新请求 Cache-Control：private / public—&gt;中间节点是否缓存资源 RESTful HTTP: 按规范使用 HTTP]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 的消息机制]]></title>
      <url>%2F2019%2F12%2F14%2FAndroid%20%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Android 消息机制主要指 Handler 的运行机制及 Handler 所附带的 MessageQueue 和 Looper 的工作过程。其作用是将一个任务切换到某个指定的线程中去执行。 首先分析下 ThreadLocal ThreadLocal 工作原理ThreadLocal 是线程内部的数据存储类，可以指定线程中的存储数据，不同线程持有自己的数据。使用场景： 某些数据已线程为作用域且不同线程具有不同的数据副本。 123456789101112131415161718192021final ThreadLocal&lt;Boolean&gt; mThreadLocal = new ThreadLocal&lt;&gt;();mThreadLocal.set(true);System.out.println(Thread.currentThread().getName() + &quot;threadLocal: &quot; + mThreadLocal.get());new Thread() &#123; @Override public void run() &#123; mThreadLocal.set(false); System.out.println(Thread.currentThread().getName() + &quot;threadLocal: &quot; + mThreadLocal.get()); &#125;&#125;.start();new Thread() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;threadLocal: &quot; + mThreadLocal.get()); &#125;&#125;.start(); 查看打印日志为 mainthreadLocal: trueThread-0threadLocal: falseThread-1threadLocal: null 可以发现，使用的是同一个 ThreadLocal 对象，但是主线程和线程1中的布尔值是不相同的，同时线程2由于没有设置，因此打印为 null。ThreadLocal 内部会从各自的线程中取出 ThreadLocalMap，然后根据索引去查找对应的 value 值。由于每个线程中都会有一个 ThreadLocalMap，因此线程之间获取的数据互不干扰。 ThreadLocal 内部实现 set 方法： 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 首先从当前的 Thread 中拿到 ThreadLocalMap 对象，如果为空则创建一个新的 ThreadLocalMap 对象，然后将数据存入，不为空则直接赋值。其中 ThreadLocalMap 是一个类似于 Map 的集合，其保存着以自己为 key 的数据，源码如下： 1234567891011121314151617181920212223242526272829303132private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don&apos;t use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 可以发现，相同的 key 则替换，否则在后面追加。 get方法 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 与 set 方法类似，从 ThreadLocalMap 中获取值，如果找到则返回，否则调用 setInitialValue() 方法，查看其源码为： 12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 相当于创建一个值，其中会通过 initalValue() 初始化 value，查看方法为： 123protected T initialValue() &#123; return null;&#125; 可以发现，初始值为 null，这就可以理解上述例子中为什么线程2 中返回值为 null。 消息机制讲完 ThreadLocal 可以讲消息机制原理，消息机制是通过通过 Handler.sendMessage 或 post() 方法去发送一个消息，消息存储在消息队列 MessageQueue 中，然后通过 Looper 不断的循环取出消息交给 Handler 去处理。 首先介绍 MessageQueue MessageQueueMessageQueue 主要包含插入和读取两个操作，同时在读取过程中也会删除响应的 Message。 读取操作：enqueueMessage() 向消息队列中插入一条数据，通过链表来维护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 可以看出其通过单链表的形式插入一条 Message。 读取操作：next() : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ....... &#125; &#125; 可以发现，其为一个无限循环方法，当没有消息时会阻塞，当有消息到来时则会返回消息，并移除。 LooperLooper 是消息机制中的重要角色，它会一直从 MessageQueue 中取消息，其内部会构建 MessageQueue 消息队列。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 当在子线程中使用 Looper 时得需要调用 Looper 的 prepare 方法： 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 其中 Looper 内部存在 ThreadLocal 对象，这样保证每个线程中的只有一个对应的 Looper。通过 时候上述分析 ThreadLocal 原理可以知道，其余线程不会拿到非自己线程的 Looper。当在子线程中调用完 prepare() 方法后，其并不会正常工作，需要调用 loop() 方法去开启循环： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell &apos;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&apos; final int thresholdOverride = SystemProperties.getInt(&quot;log.looper.&quot; + Process.myUid() + &quot;.&quot; + Thread.currentThread().getName() + &quot;.slow&quot;, 0); boolean slowDeliveryDetected = false; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; try &#123; msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (slowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, &quot;Drained&quot;); slowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;, msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg); &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 可以发现，其会一直循环，除非当 MessageQueue 中 message 为 null 才会跳出循环，其中还会调用 msg.target.dispatchMessage(msg) 来交给发送 message 的 handler 进行处理。该方法的执行是在创建 Handler 的 Looper 中执行的，因此在这里完成了线程的切换。 Handler 的工作原理首先介绍 Handler 的使用方式： 1234567891011121314151617private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); System.out.println(msg.obj); &#125;&#125;;Thread thread = new Thread() &#123; @Override public void run() &#123; Message message = Message.obtain(); message.obj = &quot;Hello&quot;; mHandler.sendMessage(message); &#125; &#125;; 可以发现 Handler 的主要工作是 发送消息 和 接受消息，发送消息有 post 和 send 方法：1.send 等方法： sendMessage(Message msg) sendEmptyMessage(int what) sendEmptyMessageAtTime(int what, long uptimeMillis) sendEmptyMessageDelayed(int what, long delayMillis)2.post 等方法： post(Runnable r) postAtTime(Runnable r, long uptimeMillis) postDelayed(Runnable r, long delayMillis)等消息，查看 api 可以发现其中最后都会调用到 sendMessageAtTime(Message msg, long uptimeMillis)，只不过不同的是 post 系列方法参数为 Runnable，其会赋值到 Message 的 callback 中。 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 而 enqueueMessage 方法会调用到 MessageQueue 中的 enqueueMessage 方法，从而进行上述讲到的消息队列的插入。 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 插入消息后，通过 Looper.loop 方法调用到 MessageQueue.next 方法将消息取出，然后通过 msg.target.dispatchMessage 进行处理消息，可以发现 msg.target 就是发送该消息的 Handler。Handler 中 dispatchMessage 方法如下： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 首先是 msg.callback 不为空，即使用 post 系列方法发送的消息，则会调用到 handleCallback(msg) 方法： 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 可以看到由于其 callback 为 Runnable 所以直接调用 run 方法处理。当 Handler 中不为空时，会调用 mCallback 中的 handleMessage 方法，其中 mCallback 是在创建 Handler 时传入的，其是接口： 1234567public interface Callback &#123; /** * @param msg A &#123;@link android.os.Message Message&#125; object * @return True if no further handling is desired */ public boolean handleMessage(Message msg);&#125; 如果 mCallback 为空则会走到 Handler 中的 handleMessage 方法，由此可以看到整个 Handler 的基本流程。 Handler 的构造方法如下： 1234567891011121314151617181920212223public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 通过查看 Handler 的构造方法可以看到会调用 Looper.myLooper 拿到当前线程的 Looper，当 Looper 为空时会报错，因此当在子线程调用时，需要创建 Looper 并开启循环。 那么为什么主线程中不需要创建 Looper 呢，原因是在 ActivityThread 中的 main 方法中帮我们生产了主线程中的 looper： 123456789101112131415161718192021222324public static void main(String[] args) &#123; ...... Looper.prepareMainLooper(); ........ ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 可以看到通过 Looper.prepareMainLooper() 创建了主线程中的 Looper，并通过 Looper.loop() 开启了循环，通过 thread.getHandler 为 ActivityThread.H ，其内部定义了一组消息类型，包含四大组件的启动和停止等。 总结通过分析上述内容，其中的关系有点乱，因此在这里做下总结： Looper 中构造方法中会创建 MessageQueue MessageQueue 中存放着 Handler 发送的 Message。 Message 内部保存着创建消息的 Handler。 Handler 内部持有这 Looper 所创建的 MessageQueue。 图如下： send 或 post 方法中会有 delay 方法，其中会调用到： 1234567public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 可以发现，delay 时间为 当前系统启动以来，不包括深度睡眠的时间加上所需要延迟的时间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kotlin 默认参数注意事项]]></title>
      <url>%2F2019%2F12%2F04%2FKotlin%20%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[Kotlin 中实现方法的重载Kotlin 方法或构造函数中的参数可以给出默认值，来达到 Java 方法中的重载功能，如下 Java 代码 123456789101112131415161718public class FunTestJava &#123; public static void hello() &#123; System.out.println(&quot;Hello, world!&quot;); &#125; public static void hello(String name) &#123; System.out.println(&quot;Hello, &quot; + name + &quot;!&quot;); &#125; public static void hello(String name, int age) &#123; if (age &gt; 0) &#123; System.out.println(&quot;Hello, &quot; + name + &quot;(&quot; + age + &quot;)!&quot;); &#125; else &#123; System.out.println(&quot;Hello, &quot; + name + &quot;!&quot;); &#125; &#125;&#125; Kotlin 代码 12345678910object FunTest &#123; fun sayHello(name: String = &quot;world&quot;, age: Int = 0) &#123; if (age &gt; 0) &#123; println(&quot;Hello, $&#123;name&#125;($&#123;age&#125;)!&quot;) &#125; else &#123; println(&quot;Hello, $&#123;name&#125;!&quot;) &#125; &#125;&#125; 在 Kotlin 类代码中调用，可以实现重载： 123FunTest.sayHello()FunTest.sayHello(&quot;Kotlin&quot;)FunTest.sayHello(&quot;Kotlin&quot;, 16) 但是在 Java 类中无法按 Kotlin 这种方式调用，必须全量声明参数： 1FunTest.INSTANCE.sayHello(&quot;Kotlin&quot;,18); 原因分析，将编译后的代码转为 java 代码查看发现，上述方法被转为如下： 1234567891011121314151617181920212223242526272829public final void sayHello(@NotNull String name, int age) &#123; Intrinsics.checkParameterIsNotNull(name, &quot;name&quot;); String var3; if (age &gt; 0) &#123; var3 = &quot;Hello, &quot; + name + &apos;(&apos; + age + &quot;)!&quot;; System.out.println(var3); &#125; else &#123; var3 = &quot;Hello, &quot; + name + &apos;!&apos;; System.out.println(var3); &#125; &#125; // $FF: synthetic method public static void sayHello$default(FunTest var0, String var1, int var2, int var3, Object var4) &#123; if ((var3 &amp; 1) != 0) &#123; var1 = &quot;world&quot;; &#125; if ((var3 &amp; 2) != 0) &#123; var2 = 0; &#125; var0.sayHello(var1, var2); &#125;FunTest.sayHello$default(FunTest.INSTANCE, (String)null, 0, 3, (Object)null);FunTest.sayHello$default(FunTest.INSTANCE, &quot;Kotlin&quot;, 0, 2, (Object)null);FunTest.INSTANCE.sayHello(&quot;学而思&quot;, 10); 可以发现，转换后会生成一个正常的 sayHello 方法以及 sayHello$default 方法，当 Kotlin 调用默认参数时实际上是调用的 sayHello$default 方法，其和 Java 中重载方法并不一样，因此 Java 中不能使用。 存在的问题当自定义 View 时，用 Java 编写如下： 12345678910111213public class TestViewJava extends AppCompatTextView &#123; public TestViewJava(Context context) &#123; super(context); &#125; public TestViewJava(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public TestViewJava(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125;&#125; 一般声明三种构造函数，用 Kotlin 编写： 123456class TestViewKotlin( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : AppCompatTextView(context, attrs, defStyleAttr) &#123;&#125; 根据默认参数问题可以知道，不需要为不同参数编写另一个构造方法。 这个自定义的 View，使用在 XML 布局中时，编译不会出错，但是运行时，会报 NoSuchMethodException 错误，如下： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;com.li.panda.busquery.TestViewKotlin android:id=&quot;@+id/tvKTTest&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:background=&quot;@color/colorPrimary&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 报错如下： Caused by: android.view.InflateException: Binary XML file line #9: Binary XML file line #9: Error inflating class com.li.panda.busquery.TestViewKotlinCaused by: android.view.InflateException: Binary XML file line #9: Error inflating class com.li.panda.busquery.TestViewKotlinCaused by: java.lang.NoSuchMethodException: [class android.content.Context, interface android.util.AttributeSet] 原因就是上面分析的原理，Kotlin 并不会存在多个相同名称的方法进行重载，用这样写生成的构造方法属于 合成方法 当 inflate 布局时找不到方法，将字节码转为 Java 代码后查看： 1234567891011121314151617public TestViewKotlin(@NotNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; Intrinsics.checkParameterIsNotNull(context, &quot;context&quot;); super(context, attrs, defStyleAttr); &#125; // $FF: synthetic method public TestViewKotlin(Context var1, AttributeSet var2, int var3, int var4, DefaultConstructorMarker var5) &#123; if ((var4 &amp; 2) != 0) &#123; var2 = (AttributeSet)null; &#125; if ((var4 &amp; 4) != 0) &#123; var3 = 0; &#125; this(var1, var2, var3); &#125; 解决方法使用 @JvmOverloads 注解方式在构造函数前声明，如下： 123456class TestViewKotlin @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : AppCompatTextView(context, attrs, defStyleAttr) &#123;&#125; 然后运行，不会报错，将字节码转为 Java 代码后发现： 1234567891011121314151617181920212223242526272829@JvmOverloads public TestViewKotlin(@NotNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; Intrinsics.checkParameterIsNotNull(context, &quot;context&quot;); super(context, attrs, defStyleAttr); &#125; // $FF: synthetic method @JvmOverloads public TestViewKotlin(Context var1, AttributeSet var2, int var3, int var4, DefaultConstructorMarker var5) &#123; if ((var4 &amp; 2) != 0) &#123; var2 = (AttributeSet)null; &#125; if ((var4 &amp; 4) != 0) &#123; var3 = 0; &#125; this(var1, var2, var3); &#125; @JvmOverloads public TestViewKotlin(@NotNull Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0, 4, (DefaultConstructorMarker)null); &#125; @JvmOverloads public TestViewKotlin(@NotNull Context context) &#123; this(context, (AttributeSet)null, 0, 6, (DefaultConstructorMarker)null); &#125; 发现确实保存了构造方法的重载，但是当使用 @JvmOverloads 关键字时，需要注意参数初始化的默认设置。 @JvmOverloads 默认值处理规则： 对象，默认值为 null。 基础数据类型，默认值为基本数据类型的默认值。例如 Int 就是 0，Boolean 就是 false。 比如上述自定义 View，构造方法参数 defStyleAttr 默认会为 0 ，但是在正常情况下自定义 View时候会传入默认 defStyleAttr 值，其值不为 0，因此在用这种方式编写自定义 Veiw 时注意，以免引起一些问题。 因此，自定义 View 推荐重写多个构造函数，而不是使用默认参数来实现。 总结 Kotlin 可以通过对一个方法的参数指定默认值的方式，来完成类似 Java 中「方法重载」的效果。 若想与 Java 的重载方法保持一致，可以使用 @JvmOverloads 注解，会自动生成该方法的全部重载方法。 在自定义 View 时，需要注意指定参数 defStyleAttr 的默认值，而不应该是 0。（不推荐这种方法自定义 View）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kotlin 直接使用 View ID 的问题]]></title>
      <url>%2F2019%2F12%2F01%2FKotlin%20%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%20View%20ID%20%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[使用方法Kotlin 中可以直接通过 View 的 ID 来访问 View，被称为静态布局引入，首先使用要在 module 下的 build.gradle 配置如下插件。 1apply plugin: &apos;kotlin-android-extensions&apos; 然后在 Activity 或者 Fragment 中直接根据 View ID 可以访问该 View，布局文件如下：12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tvTest&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;@color/colorPrimary&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/rvTest&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@id/tvTest&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; Activity 中使用： 12345678910open class MainActivity : AppCompatActivity() &#123; private val testBeans: MutableList&lt;TestBean&gt;? = mutableListOf() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) tvTest.text = &quot;Hello Kotlin&quot; &#125;&#125; 原理分析为什么可以直接通过 View ID 访问到该控件，通过 ByteCode 对编译后的 kotlin class文件（build/tmp/kotlin-classes目录下）进行分析: 12345678910111213141516171819202122232425public class MainActivity extends AppCompatActivity &#123; private final List testBeans; private HashMap _$_findViewCache; protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.setContentView(2131296284); TextView var10000 = (TextView)this._$_findCachedViewById(id.tvTest); Intrinsics.checkExpressionValueIsNotNull(var10000, &quot;tvTest&quot;); var10000.setText((CharSequence)&quot;Hello Kotlin&quot;); &#125; public View _$_findCachedViewById(int var1) &#123; if (this._$_findViewCache == null) &#123; this._$_findViewCache = new HashMap(); &#125; View var2 = (View)this._$_findViewCache.get(var1); if (var2 == null) &#123; var2 = this.findViewById(var1); this._$_findViewCache.put(var1, var2); &#125; return var2; &#125; 可以发现，内部生成了_$_findCachedViewById()方法，内部利用 HashMap 存储使用过的 View，避免 findViewById() 。 存在的问题当某些场景使用 LayoutInflate， inflate 的布局中无法直接使用 View ID 来访问，需借助 inflate 的 View 对象去拿到该View ，比如 Recyclerview 中 adapter ： 1234567891011121314151617181920212223242526class TestAdapter(private var tesBeans: MutableList&lt;TestBean&gt;?) : RecyclerView.Adapter&lt;TestAdapter.TestHolder&gt;() &#123; private lateinit var context: Context override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TestHolder &#123; context = parent.context return TestHolder(LayoutInflater.from(parent.context).inflate(R.layout.item, parent, false)) &#125; override fun getItemCount(): Int &#123; return tesBeans?.size ?: 0 &#125; override fun onBindViewHolder(holder: TestHolder, position: Int) &#123; tesBeans?.get(position)?.run &#123; holder.itemView.tvName.text = &quot;这是name：$name&quot; holder.itemView.tvAge.text = &quot;这是age:$age&quot; &#125; holder.itemView.setOnClickListener &#123; context.startActivity(Intent(context, TestActivity::class.java)) &#125; &#125; class TestHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#125; 借助 inflate 的 Inflate 的对象去拿到 View 对象 通过 ByteCode 对编译后的 kotlin class文件进行分析可以发现，其并没有生成与上面所提到的 HashMap 做缓存，而是直接转变为 findViewById，如下： 1234567891011121314151617181920212223242526272829public void onBindViewHolder(@NotNull TestAdapter.TestHolder holder, int position) &#123; Intrinsics.checkParameterIsNotNull(holder, &quot;holder&quot;); List var10000 = this.tesBeans; if (var10000 != null) &#123; TestBean var6 = (TestBean)var10000.get(position); if (var6 != null) &#123; TestBean var3 = var6; int var5 = false; View var7 = holder.itemView; Intrinsics.checkExpressionValueIsNotNull(var7, &quot;holder.itemView&quot;); //使用findViewById查找控件 TextView var8 = (TextView)var7.findViewById(id.tvName); Intrinsics.checkExpressionValueIsNotNull(var8, &quot;holder.itemView.tvName&quot;); var8.setText((CharSequence)(&quot;这是name：&quot; + var3.getName())); var7 = holder.itemView; Intrinsics.checkExpressionValueIsNotNull(var7, &quot;holder.itemView&quot;); //使用findViewById查找控件 var8 = (TextView)var7.findViewById(id.tvAge); Intrinsics.checkExpressionValueIsNotNull(var8, &quot;holder.itemView.tvAge&quot;); var8.setText((CharSequence)(&quot;这是age:&quot; + var3.getAge())); &#125; &#125; holder.itemView.setOnClickListener((OnClickListener)(new OnClickListener() &#123; public final void onClick(View it) &#123; TestAdapter.access$getContext$p(TestAdapter.this).startActivity(new Intent(TestAdapter.access$getContext$p(TestAdapter.this), TestActivity.class)); &#125; &#125;)); &#125; 因此所产生的问题是，Kotlin 虽然干掉了 findViewById()，使用 HashMap 去存储 View，但是使用 View.view 的操作方式，依然会回归到原始的 findViewById()，当对该 View 对象多次操作时候会产生很多次 findViewById 从而对性能造成影响。因此应避免这种使用方法，如果要使用进行一次处理，比如在 holder 中直接保存该变量，后续使用直接使用变量的方式进行操作View，如下： 123456789101112131415161718192021222324252627282930313233class TestAdapter(private var tesBeans: MutableList&lt;TestBean&gt;?) : RecyclerView.Adapter&lt;TestAdapter.TestHolder&gt;() &#123; private lateinit var context: Context override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TestHolder &#123; context = parent.context return TestHolder(LayoutInflater.from(parent.context).inflate(R.layout.item, parent, false)) &#125; override fun getItemCount(): Int &#123; return tesBeans?.size ?: 0 &#125; override fun onBindViewHolder(holder: TestHolder, position: Int) &#123; tesBeans?.get(position)?.run &#123;// holder.itemView.tvName.text = &quot;这是name：$name&quot;// holder.itemView.tvAge.text = &quot;这是age:$age&quot; holder.tvName.text = &quot;这是name：$name&quot; holder.tvAge.text = &quot;这是age:$age&quot; &#125; holder.itemView.setOnClickListener &#123; context.startActivity(Intent(context, TestActivity::class.java)) &#125; &#125; class TestHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; // 回归原始方法，此处声明，后续使用 val tvName: TextView = itemView.tvName val tvAge: TextView = itemView.tvAge &#125; 总结Kotlin 可以直接通过 View ID 访问布局内的 View 对象。其会利用一个 HashMap 结构，实现了缓存，避免 findViewById() 被重复调用。但是当使用 View.view 这种调用方式时，其实是得不到任何优化的，就是很直接的每次利用 findViewById()拿 ID 指定的 View 进行操作，所以我们要尽量避免这样的使用方式，或者在使用时进行处理，避免使用时都去 findViewById()。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ViewDragHelper学习及使用]]></title>
      <url>%2F2019%2F03%2F24%2FViewDragHelper%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[工作中需要开发一个类似于抽屉式的滑动的 View，同过调研及查找资料发现ViewDragHelper可以实现此类方式，在此记录下ViewDragHelper的学习及使用。 首先 ViewDragHelper 分为三部： 创建 ViewDragHelper 实例，通过ViewDragHelper.create(ViewGroup forParent, float sensitivity, Callback cb)创建ViewDragHelper实例，其中：ViewGroup：当前的ViewGroupsensitivity:设置滑动灵敏度，通常为 1cb:拖拽回调，用来处理拖动位置相关回调 实现 ViewDragHelper.Callback() 相关方法： 1234567891011121314151617mViewDragHelper = ViewDragHelper.create(this, 1.0f, new ViewDragHelper.Callback() &#123; @Override public boolean tryCaptureView(@NonNull View child, int pointerId) &#123; return false; &#125; @Override public int clampViewPositionVertical(@NonNull View child, int top, int dy) &#123; return super.clampViewPositionVertical(child, top, dy); &#125; @Override public int clampViewPositionHorizontal(@NonNull View child, int left, int dx) &#123; return super.clampViewPositionHorizontal(child, left, dx); &#125; &#125; 该回调可以移动相关的处理，比如哪些 view 可以移动，以及移动的边界处理等。其中参数如下： tryCaptureView: 返回 true 表示捕获相关 View，根据传入的 child 确定要捕获的 view clampViewPositionVertical(View child, int top, int dy)、clampViewPositionHorizontal(View child, int left, int dx): child 移动边界控制，其中 top,left 表示移动到的位置。 处理 ViewGroup 的触摸事件 12345678910@Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mViewDragHelper.shouldInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mViewDragHelper.processTouchEvent(event); return true; &#125; onInterceptTouchEvent:交给 mViewDragHelper.shouldInterceptTouchEvent(ev) 进行处理 onTouchEvent：交给 mViewDragHelper.processTouchEvent(event) 进行处理 简单的使用就如上所示，当如，其中如果进行复杂的处理，还需更多的用法，比如： 边界触摸检测 拖拽释放回调 移动到某个指定位置 比如如下重写的方法： 123456789101112131415161718192021222324252627282930313233343536mViewDragHelper = ViewDragHelper.create(this, 1.0f, new ViewDragHelper.Callback() &#123; @Override public boolean tryCaptureView(@NonNull View child, int pointerId) &#123; return child == mDragView; &#125; @Override public int clampViewPositionVertical(@NonNull View child, int top, int dy) &#123; if (top &gt; getHeight() - mDragViewHight) &#123; top = getHeight() - mDragViewHight; &#125; else if (top &lt; MIN_TOP) &#123; top = MIN_TOP; &#125; return top; &#125; @Override public int getViewVerticalDragRange(@NonNull View child) &#123; return getMeasuredHeight() - child.getMeasuredHeight(); &#125; @Override public void onViewPositionChanged(@NonNull View changedView, int left, int top, int dx, int dy) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy); LinearLayout.LayoutParams bottomViewLayoutPara = (LayoutParams) mBottomView.getLayoutParams(); bottomViewLayoutPara.height = bottomViewLayoutPara.height + dy * -1; mBottomView.setLayoutParams(bottomViewLayoutPara); LinearLayout.LayoutParams topViewLayoutPara = (LayoutParams) mTopView.getLayoutParams(); topViewLayoutPara.height = topViewLayoutPara.height + dy; mTopView.setLayoutParams(topViewLayoutPara); &#125; &#125;); &#125; 其中： getViewVerticalDragRange 返回child 垂直移动范围的距离，如果不加，当有点击事件之后则不触发 onViewPositionChanged 当位置改变进行回调 同时除了以上方法之外还有其余如下方法： onViewDragStateChanged:ViewDragHelper状态改变时进行回调（IDLE,DRAGGING,SETTING） onEdgeTouched:触摸到边界是回调 onEdgeDragStarted:边界拖动时回调，需设置 setEdgeTrackingEnabled() ,可以设置如下 EDGE_LEFT：左边界 EDGE_TOP：上边界 EDGE_RIGHT：右边界 EDGE_BOTTOM：底部边界附实现效果：附代码（DragView）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class DragView extends LinearLayout &#123; private View mTopView; private View mDragView; private View mBottomView; private ViewDragHelper mViewDragHelper; private int mDragViewHight; final int MIN_TOP = 100; public DragView(Context context) &#123; super(context); init(); &#125; public DragView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public DragView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mViewDragHelper = ViewDragHelper.create(this, 1.0f, new ViewDragHelper.Callback() &#123; @Override public boolean tryCaptureView(@NonNull View child, int pointerId) &#123; return child == mDragView; &#125; @Override public int clampViewPositionVertical(@NonNull View child, int top, int dy) &#123; if (top &gt; getHeight() - mDragViewHight) &#123; top = getHeight() - mDragViewHight; &#125; else if (top &lt; MIN_TOP) &#123; top = MIN_TOP; &#125; return top; &#125; @Override public int getViewVerticalDragRange(@NonNull View child) &#123; return getMeasuredHeight() - child.getMeasuredHeight(); &#125; @Override public void onViewPositionChanged(@NonNull View changedView, int left, int top, int dx, int dy) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy); LinearLayout.LayoutParams bottomViewLayoutPara = (LayoutParams) mBottomView.getLayoutParams(); bottomViewLayoutPara.height = bottomViewLayoutPara.height + dy * -1; mBottomView.setLayoutParams(bottomViewLayoutPara); LinearLayout.LayoutParams topViewLayoutPara = (LayoutParams) mTopView.getLayoutParams(); topViewLayoutPara.height = topViewLayoutPara.height + dy; mTopView.setLayoutParams(topViewLayoutPara); &#125; &#125;); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mViewDragHelper.shouldInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mViewDragHelper.processTouchEvent(event); return true; &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); mTopView = getChildAt(0); mDragView = getChildAt(1); mBottomView = getChildAt(2); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mDragViewHight = mDragView.getMeasuredHeight(); &#125;&#125; 参考链接- 鸿洋_]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每日算法（反转整数）-11.13]]></title>
      <url>%2F2018%2F11%2F13%2F%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%EF%BC%88%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
      <content type="text"><![CDATA[今天下班时间比较晚，回来后只学习了一道算法，反转整数，下面开始记录题以及自己的分析。 反转整数 给定一个 32 位有符号整数，将整数中的数字进行反转。 示例1：12输入: 123输出: 321 示例2：12输入: -123输出: -321 示例 3:12输入: 120输出: 21 给定一个 32 位有符号整数，将整数中的数字进行反转。假设环境只能存储32位有符号整数，其数值范围是 [−2^31, 2^31−1]。根据这个假设，如果反转后的整数溢出，则返回 0。 根据题目判断类似于反转字符串，首先自己不假思索的用StringBuilder进行了实现，但是这样的话自己认为根本就不叫算法题，因此自己重新思考去实现，思路如下：首先对一个数进行整除然后while循环，之后再进行赋值操作1234int num = 0;while(x!=0)&#123; num = num*10+x%10;&#125; 但是该方法并没有进行越界处理，当写出来之后查看解析发现处理的很巧妙：1234567891011public int reverse(int x) &#123; int num = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; if (num &gt; Integer.MAX_VALUE/10 || (num == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; if (num &lt; Integer.MIN_VALUE/10 || (num == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; num = num * 10 + pop; &#125; return num; &#125; 思想是如果num大于Integer的最大边界/10则后面其无论加多少值都为越界，同样的道理因为题目规定最大值为2^31-1为2147483647，如果num==Integer.MAX_VALUE/10，则pop大于7之后则将越界；负数同样为该原理，查看解析后发现处理很是巧妙，自己需要学的地方还是很多，继续加油！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每日算法（两数之和、两数相加）-11.12]]></title>
      <url>%2F2018%2F11%2F12%2F%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%81%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%89%2F</url>
      <content type="text"><![CDATA[今天开始记录每天学习一道两道的算法题，由简入难。今天一共学习了两道算法，一道简单一道中等，分别为两数之和、两数相加，下面开始记录题以及自己的分析。 两数之和 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。123给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 分析：刚拿到题发现并不是很难，于是很快写出如下算法：12345678910111213public int[] sumInArray(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; int val = target - nums[i]; for (int j = i; j &lt; nums.length; j++) &#123; if (nums[j] == val) &#123; return new int[] &#123; i, j &#125;; &#125; else &#123; continue; &#125; &#125; &#125; return null; &#125; 但是该方法的时间复杂度为$O(n^2)$；通过查看解析，发现使用哈希表进行处理，通过以空间换取速度的方式，可以将查找时间从 $O(n)$ 降低到 $O(1)$，但是如果出现冲突，查找时间还是可能会退化到 $O(n)$。方法如下：1234567891011public static int[] sumInArray(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int val = target - nums[i]; if (map.containsKey(val)) &#123; return new int[]&#123;map.get(val), i&#125;; &#125; map.put(nums[i], i); &#125; return null; &#125; 该方法遍历了一次，因此时间复杂度为$O(n)$，但是作为代价就是空间复杂度为$O(n)$。 两数相加 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。除了数字 0 之外，这两个数字都不会以零开头。123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析：首先拿到题目很困惑，因为很长时间没有做链表之类的题目，首先自己想到的是如果其中一个链表开头为0，则直接返回另一个链表，然后在循环进行遍历逐位相加，但是手写代码发现写不出来😓，因此去查看官方解析： 类似于纸上计算两个数字的和，首先从最低有效位也就是列表L1 和 L2 的表头开始相加。由于每位数字都应当处于 0…9 的范围内，因此两个数字的和时可能会出现“溢出”。例如，5 + 7 = 12。在这种情况下，将当前位的数值设置为 22，并将进位 carry=1 带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。 参考代码如下：123456789101112131415161718192021222324252627282930public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode p = l1; ListNode q = l2; ListNode currentNode = head; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; currentNode.next = new ListNode(sum % 10); currentNode = currentNode.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; currentNode.next = new ListNode(carry); &#125; return head.next; &#125;public class ListNode &#123; int val; ListNode next; ListNode(int value) &#123; val = value; &#125; &#125; 今天学习了两个算法，再次记录自己的学习状态，以敦促自己继续去学习]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android面试知识点总结]]></title>
      <url>%2F2017%2F09%2F14%2FAndroid%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[仅用作与记录自己看到的知识点总结，图片来源于网络 blog。 1. Activity 与 Fragment 的生命周期？Activity： 启动 Activiy：onCreate-&gt;onStart()-&gt;onResume(),Activity 进入运行状态. Activity 退居后台(Home 或启动新Activity):onPause()-&gt;onStop(). Activity 返回前台:onRestart()-&gt;onStart()-&gt;onResume(). Activity 后台期间内存不足情况下当再次启动会重新执行启动流程。 锁屏:onPause()-&gt;onStop(). 解锁:onStart()-&gt;onResume().Fragment: 创建 Fragment:onAttach()-&gt;onCreate-&gt;onCreateView()-&gt;onActivityCreate()-&gt;onStart()-&gt;onResume() 销毁 Fragment:onPause()-&gt;onStop()-&gt;onDestroyView()-&gt;onDestroy()-&gt;onDetach(). 从返回栈中回到上一个 Fragment:onDestroyView()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume().Activity 和 Fragment 关系： 2. Activity 的四种启动模式和特点？ standard(标准模式):每次启动都会创建一个新的实例，并放入栈顶。（无法使用非 Activity 类的 Context 启动该模式的 Activity，如果启动需要加上 FlAG_ACTIVITY_NEW_TASK标记创建一个栈）。 singleTop(栈顶复用模式):如果启动的 Activity 在栈顶，则该 Activity 不会重建，同时 Activity 的 onNewIntent() 方法会被调用，如果不在栈顶则通 standar 模式。 singleTask(栈内复用模式):若启动的 Activity 在栈内，则不会创建新的实例调用 onNewIntent() 方法，并将该 Activity 上面所以的 Activity 清空（如果其他应用启动该 Activity，若不存在则简历新的 Task，若存在在后台，则后台 Task 也切换到前台）。 singleInstance(单例模式):新的 Activity 直接创建新的任务栈，当该模式的 Activity 存在于某个栈中，后面任何激活该 Activity 都会重用该实例。 3. Activity 的缓存方法？Activity 由于异常终止时，系统会调用 onSaveInstanceState()来保存 Activity 状态(onStop()之前和onPause()没有既定的时序关系)。当重建时，会调用 onRestoreInstanceState()，并且把 Activity 销毁时 onSaveInstanceState()方法所保存的 Bundle 对象参数同时传递给 onSaveInstanceState()和onCreate()方法。因此，可通过 onRestoreInstanceState()方法来恢复 Activity 的状态，该方法的调用时机是在 onStart()之后。onCreate()和 onRestoreInstanceState()的区别：onRestoreInstanceState()回调则表明其中Bundle对象非空，不用加非空判断。onCreate()需要非空判断。建议使用onRestoreInstanceState(). 4. Service 的生命周期及两种启动方法。 startService 启动服务: 用于启动一个服务执行后台任务，停止服务使用 stopService(). bindService 启动服务: 启动服务进行通信，停止服务使用 unbindService(). startService/stopServiceonCreate()-&gt;onStartCommand()-&gt;onDestroy()第一次调用会触发 onCreate()和 onStartCommand，之后每次启动服务只触发 onStartCommand()无论 startService 多少次，stopService 一次就会停止服务 bindService/unbindServiceonCreate-&gt;onBind()-&gt;onUnbind()-&gt;onDestroy()第一次 bindService 会触发 onCreate 和 onBind，以后每次 bindService 都不会触发任何回调bindService 启动的生命周期依附于启动它的 Context 5. Service 保活。 在 onStartCommond()中将返回值设置为 START_STICKY 在 onDestroy()中重启 service 黑色保活：不同 app 进程利用广播相互唤起。 白色保活：启动前台 service 灰色保活：利用系统漏洞启动前台 service。 6. 广播的两种注册方法，有什么区别。 动态注册：通过调用 Context.registerReceiver 进行注册，跟随组件的生命周期，特定时刻监听广播。 静态注册：在 AndroidMainfest.xml 中声明，程序关闭后仍会调用，常驻广播，时刻监听广播。 7. Intent的使用方法及所传递的数据类型。 显示 Intent：按名指定要启动的组件 隐示 Intent：不指定特定组件，声明要执行的常规操作，从而允许其他应用中组件来处理。 Intent 可传递的数据类型：基本类型及其数组数据，String/CharSequence类型的数据及其数组数据，也可以传递Parcelable和Serializable类型的数据，以及它们的数组/列表数据。 8. ContentProvider使用方法。进行跨进程通信，实现进程间得数据交互和共享。通过 Context 中 getContentResolver()获得实例，通过 Uri 匹配进行数据的增删改查。ContentProvider 使用表的形式来组织数据，无论数据的来源是什么，ContentProvider 都会认为是一种表，然后把数据组织成表格 9. Thread、AsyncTask、IntentService的使用场景与特点。 Thread线程，独立运行与于 Activity 的，当 Activity 被 finish 后，如果没有主动停止 Thread 或者 run 方法没有执行完，其会一直执行下去。 AsyncTask 封装了两个线程池和一个 Handler，（SerialExecutor用于排队，THREAD_POOL_EXECUTOR为真正的执行任务，Handler 将工作线程切换到主线程），其必须在 UI 线程中创建，execute 方法必须在 UI 线程中执行，一个任务实例只允许执行一次，执行多次将抛出异常，用于网络请求或者简单数据处理。 IntentService：处理异步请求，实现多线程，在 onHandleIntent 中处理耗时操作，多个耗时任务会依次执行，执行完毕后自动结束。 10. 五种布局: FrameLayout、LinearLayout、 AbsoluteLayout、RelativeLayout、TableLayout 各自特点及绘制效率对比。 FrameLayout: Android 中最简单布局，所有控件默认出现在左上角，可以使用 layout_margin，layout_gravity 等属性控制子控件的相对布局位置。 LinearLayout: 一行或者一列布局空间，可使用 orientation=horizontal|vertical 来控制布局方式。 AbsoluteLayout: 自定义空间的x，y 来调整位置。 RelativeLayout: 相对布局，通过相关属性来定义空间的位置 android:layout_centerInParent=”true|false”android:layout_centerHorizontal=”true|false”android:layout_alignParentRight=”true|false” TableLayout: 将字元素的位置以表格形式进行布局。 11. Android的数据存储形式。 SQLite 数据库存储 文件存储 SharedPreference 存储 网络存储 12. SQlite 的基本操作Android 提供了 SQLiteOpenHelper 类，通过该类可以简单控制数据库的创建和升级。 onCreate(): 创建数据库 onUpgrade(): 升级数据库 两个方法必须重写，然后实现创建和升级数据库的逻辑。 getReadableDatabase()和 getWritableDatabase(): 创建或打开一个现有数据库，返回一个可对数据库进行读写操作的对象，当数据库不可写入的时候getReadableDatabase()以只读的方式返回数据库对象，getWritableDatabase()返回异常。 insert(): 插入数据 update(): 更新数据 delete(): 删除数据 query(): 查询数据 13. Android中的MVC模式。 Model（模型） View（视图） Controler（控制器） View 传送指令到 Controller，其完成逻辑后通知 Model 改变状态，Model 将新数据更新到 View。所有通信都为单向。接受指令时，一是通过 View 接受指令并传递给 Controller；另一种是直接通过 Controller 接受指令。 14. Merge、ViewStub 的作用。 Merge: 减少视图层级，可以删除多余的层级，优化 UI。 ViewStub: 按需加载，减少内存使用量、加快渲染速度。不支持 merge 标签 15. Json有什么优劣势。优点 轻量级的数据交换格式 读写更加容易 易于机器的解析和生成 缺点 语义性较差，不如 xml 直观 16. 动画有哪两类，各有什么特点？ 传统动画：帧动画和补间动画。 属性动画。区别 属性动画才是真正的实现了view的移动，补间动画对view的移动更像是在不同地方绘制了一个影子，实际的对象还是处于原来的地方。 当动画的repeatCount设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity无法释放而导致内存泄漏，而补间动画却没有问题。 xml 文件实现的补间动画，复用率极高。在Activity切换，窗口弹出时等情景中有着很好的效果。 使用帧动画时需要注意，不要使用过多特别大的图，容易导致内存不足。 17. Handler、Loop消息队列模型，各部分的作用。Android消息机制包含: MessageQuene、Handler、Looper、Message. Message: 需要春娣的消息，可以传递数据。 MessageQuene: 消息队列，通过单链表数据结构来维护消息列表，（投递和删除消息）。 Handler: 消息辅助类，向消息池发送各种消息事件 Handler.sendMessage 发送消息Handler.handleMessage 处理消息 Looper: 不断从消息队里中读取消息，按分发机制将消息分发给目标处理者。MessageQuene、Handler 和 looper 三者之间的关系：每个线程中只能存在一个Looper，保存在ThreadLocal中。主线程（UI线程）已经创建了一个Looper，所以在主线程中不需要再创建Looper，其他线程中需要创建Looper。每个线程中可以有多个Handler，即一个 Looper 可以处理来自多个 Handler 的消息。 Looper 中维护一个 MessageQueue，来维护消息队列，消息队列中的 Message 可以来自不同的 Handler。 当调用 handler.sendMessage()发送 message 时，实际上发送到与当前线程绑定的 MessageQuene 中，然后当前线程绑定的 Looper 不断从 MessageQueue 取出新的 Message，调用 msg.target.disspatchMessage(msg) 方法将消息分发到与 Message 绑定的 handler.handleMessage()中。 18. 怎样退出终止App。 创建一个集合类对所有活动进行管理，ActivityCollector，通过 list 来管理 Activity。 killProcess(android.os.Process.myPid())杀死当前程序进程。 19. Asset目录与res目录的区别。 assets：不会在 R 文件中生成相应标记，存放到这里的资源在打包时会打入程序安装包中。（通过 AssetManager 类访问这些文件） res：会在 R 文件中生成 id 标记，资源在打包时如果使用到则打包到安装包中，未使用到不会打入安装包中。 res/anim:存放动画资源res/raw：和 asset 下文件一样打包时直接打入程序安装包中（会映射到 R 文件中） Tables assets res/raw res/drawable 获取资源方式 文件路径+文件名 R.raw.xxx R.drawable.xxx 是否被压缩 NO NO YES(失真压缩) 能否获取子目录下的资源 YES NO NO 20. Android怎么加速启动Activity。 onCreate()中不执行耗时操作 把页面显示的View细分一下，放在AsyncTask里逐步显示，用handler更好。这样用户的看到的就是有层次有步骤的一个个的view的展示，不会是先看到一个黑屏，然后一下显示所有view。 最好做成动画，效果更自然。 利用多线程的目的就是尽可能的减少onCreate和onReume的时间，使得用户能尽快看到页面，操作页面。 减少主线程阻塞时间 提高 Adapter 和 AdapterView 的效率 优化布局文件 21. Android性能优化方法 布局优化：尽量减少布局文件的层级 删除布局中无用的控件和层次，有选择的使用性能较低的 ViewGroup 采用标签，ViewStub，布局重用可降低布局的层级（ViewStub提供了按需加载的功能，当需要时才会将 ViewStub 中布局加载到内存，提高了初始化效率） 避免过度绘制 绘制优化：View 的 onDraw 方法避免执行大量操作。 onDraw 中不要创建新的布局对象。 onDraw 中不做耗时任务，大量循环十分抢占 cpu 时间片，造成 View 的绘制不流畅。 内存泄漏优化 避免写出内存泄漏代码 通过分析工具（MAT、LeakCannary）找出潜在的内存泄漏方法，然后解决。 导致内存泄漏的原因: 集合类的泄漏 单例/静态变量造成内存泄漏 匿名内部类/非静态内部类造成内存泄漏 资源未关闭 响应速度的优化：避免在主线程做耗时的操作。 ListView/RecyclerView优化： 使用 viewHolder 模式来提高效率 异步加载：耗时操作放在异步线程 滑动时停止加载和分页加载 线程优化：采用线程池，避免程序中存在大量 Thread 。 其他性能优化： 不要过多的创建对象。 不要过多使用枚举类，枚举占用内存空间要比整型大。 常量使用 static final 修饰。 使用 Android 特有的数据结构。 适当采用软引用和弱引用。 采用内存缓存和磁盘缓存。 尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。 22. Android中软引用与弱引用的应用场景。Java 引用类型分类：在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。 软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。 如果只是想避免 OOM 异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。 23. Bitmap 压缩策略 加载 Bitmap 的方式： BitmapFactory 四类方法： decodeFile(文件系统) decodeResourece(资源) decodeStream(输入流) decodeByteArray(字节数) BitmapFactory.opeions 参数 inSampleSize 采样率，对图片高和宽进行缩放，以最小比进行缩放（一般取值为2的指数）。通常是根据图片宽高实际的大小/需要的宽高大小，分别计算出宽和高的缩放比。但应该取其中最小的缩放比，避免缩放图片太小，到达指定控件中不能铺满，需要拉伸从而导致模糊。 inJustDecodeBounds 获取图片的宽高信息，交给 inSampleSize 参数选择缩放比。通过inJustDecodeBounds=true，然后加载图片就可以实现只解析图片的宽高信息，并不会真正的加载图片，所以这个操作是轻量级的。当获取了宽高信息，计算出缩放比后，然后在将inJustDecodeBounds=false,再重新加载图片，就可以加载缩放后的图片。 高效加载 Bitmap 的流程 将 BitmapFactory.Options 的 inJustDecodeBounds 参数设为 true 并加载图片 从 BitmapFactory.Options 中取出图片原始的宽高信息，对应于 outWidth 和 outHeight 参数 根据采样率规则并结合目标 view 的大小计算出采样率 inSampleSize 将 BitmapFactory.Options 的 inJustDecodeBounds 设置为 false 重新加载图片 24. 自定义View过程：onMeasure()、onLayout()、onDraw() onMeasure()方法：单一 View，一般重写此方法，针对 wrap_content 情况，规定 View 默认的大小值，避免于 match_parent 情况一致。ViewGroup，若不重写，就会执行和单子View 中相同逻辑，不会测量子 View。一般会重写 onMeasure()方法，循环测量子View。 onLayout()方法:单一 View，不需要实现该方法。ViewGroup 必须实现，该方法是个抽象方法，实现该方法，来对子 View 进行布局。 onDraw()方法：无论单一View，或者ViewGroup都需要实现该方法，因其是个空方法. 25. 事件分发机制事件分发机制详解 26. Android长连接，怎么处理心跳机制。 长连接：长连接是建立连接之后, 不主动断开. 双方互相发送数据, 发完了也不主动断开连接, 之后有需要发送的数据就继续通过这个连接发送. 心跳包：其实主要是为了防止NAT超时，客户端隔一段时间就主动发一个数据，探测连接是否断开 服务器处理心跳包：假如客户端心跳间隔是固定的, 那么服务器在连接闲置超过这个时间还没收到心跳时, 可以认为对方掉线, 关闭连接. 如果客户端心跳会动态改变, 应当设置一个最大值, 超过这个最大值才认为对方掉线. 还有一种情况就是服务器通过TCP连接主动给客户端发消息出现写超时, 可以直接认为对方掉线. Android微信智能心跳方案 27. Zygote的启动过程在Android系统里面，zygote是一个进程的名字。Android是基于Linux System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。 28. Android IPC:Binder原理。 IPC:不同进程之间彼此是不能共享的，而内核空间却是可共享的。Client进程向Server进程通信，利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。 Binder原理:Binder通信采用C/S架构，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。架构图如下所示： Binder 四个角色： Client进程：使用服务的进程 server 进程：提供服务的进程 ServiceManager 进程：将字符型是的 Binder 名字转为 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 名字获取到 Server 中 Binder 实体的引用。 Binder 驱动：进程间 Binder 通信的建立，Binder 在进程间的传递，Binder 引用计数管理，数据包在进程间传递和交互等一系列底层支持。Binder 运行机制： 注册服务：Server 在 ServiceManager 注册服务 获取服务：Client 从 ServiceManager 获取相应的 Service 使用服务：Client 根据得到的 Service 信息建立与 Service 所在的 Server 进程通信的通路可与 Server 进行交互。 29. Android 5.0，6.0，7.0 8.0新特性。 5.0: Material Design 支持多种设备 全新通知中心 支持64位 ART 虚拟机 电池续航改进 全新“最近应用程序” 安全性改进 不同数据独立保存 改进搜索 支持蓝牙4.1、USB Audio、多人分享等 6.0： 动态权限管理 系统层支持指纹识别 APP 关联 Android Pay 电源管理 TF 卡默认存储 7.0： 分屏多任务 下拉快捷开关 新通知消息 夜间模式 流量保护模式 全新设置样式 改进 Doze 休眠机制 系统级电话黑名单 菜单键快速切换应用 8.0： 画中画 通知标志 自动填充框架 系统优化 后台限制 等等优化很多Android 8.0 致谢：Android 校招面试指南Android 开发工程师面试指南特别感谢：stormzhang，关注张哥以来分享的东西对自己帮助很大。 stormzhang博客 公众号 知识星球]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运用约束性统计机器翻译进行 Aspect-Level 的跨语言情感分类]]></title>
      <url>%2F2017%2F03%2F20%2F%E8%BF%90%E7%94%A8%E7%BA%A6%E6%9D%9F%E6%80%A7%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E8%BF%9B%E8%A1%8C-Aspect-Level-%E7%9A%84%E8%B7%A8%E8%AF%AD%E8%A8%80%E6%83%85%E6%84%9F%E5%88%86%E7%B1%BB-5%2F</url>
      <content type="text"><![CDATA[本文是对 Aspect-Level Cross-lingual Sentiment Classiﬁcation with Constrained SMT 论文的 的一些笔记及理解，方便自己理解以及其他人的参考。 如有其他人看到我的博客的内容后请在留言处留下自己的意见和对我所理解的错误的指正，谢谢！ 由于自己英语能力有限，其中一部分词语可能理解有误，希望指正！ 传统的情感分析方法主要是基于： 基于机器学习的方法：通过对特征进行提取标记的监督学习方法。 基于词汇的方法：通过意见短语或词汇的关联规则。 而大多的情感分类方法主要分为三种资源和文本： 训练：用于训练分类器的资源（搜集的训练示例和词汇）。测试：用来分析情感意见的资源。输出：输出的分类结果。 传统的跨语言情感分类方法是基于 文档 或 句子 的粗粒度层面，由于不涉及到特殊的标记所以很容易进行语言翻译，而在 Aspect 层面标记依赖于一系列带特征标记的意见单元，在翻译到另一种语言时需要映射两种语言之间的意见单元，而在 aspect 层面由于标签依赖于标记的一组特定意见单元有关，当被转移到另一种语言时，需要映射两种语言之间的意见单元。 因此提出一种保留意见单元边界的翻译方法，这样避免了转换后需要进行源语言和目标语言之间的意见单元映射（词对齐）。该方法主要有两种用例：用例1：用训练语言训练 LTRAIN 的分类器对测试语言 LTEST 进行情感极性测试，得出的 LOUT是测试语言的情感极性。由（1）表示。$$L_{TRAIN} \neq L_{TEST}; L_{OUT} = L_{TEST} (1)$$通常有两种方法：a. 将可用训练资源翻译到测试语言中去然后构建分类器，并用测试语言进行测试得出结果.b. 将测试语言翻译到目标语言中并得出结果，并将得到的意见单元翻译回源语言，并将结果映射到测试集上去。 SA为情感分析，T 为翻译，Proj 为映射，Learn 为学习。 用例2：用训练语言训练分类器，但是我们需要对不同的语言进行分析结果，因此公式（2）成立。$$ L_{OUT} \neq L_{TEST}（2）$$通常有两种方法：c. 在测试语言中分析测试语言的的情感极性，并且把结果翻译到期望的语言中去，即：$$L_{TRAIN} = L_{TEST}$$d. 测试语言首先被翻译到期望语言中，并且用期望语言的情感分析方法进行测试，即：$$L_{TRAIN} = L_{OUT}$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于 Aspect 的情感分析]]></title>
      <url>%2F2017%2F03%2F06%2F%E5%9F%BA%E4%BA%8E-Aspect-%E7%9A%84%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[写本文的目的在于记录自己在阅读 Bing Liu 的 Sentiment Analysis and Opinion Mining 的一些笔记以及对文章中所写信息的理解，方便自己理解以及其他人的参考。 本篇内容主要是自己对该书第五章的内容 Aspect-based Sentiment Analysis 的理解，如有其他人看到我的博客的内容后请在留言处留下自己的意见和对我所理解的错误的指正，谢谢！ 由于自己英语能力有限，其中一大部分词语可能理解有误，希望指正！ 基本概念在传统的文档或句子级别的情感分析方面，在分析是主要有五部分组成，分别是 ( ei, aij, sijkl, hk, tl ). ei : 一个实体或目标的名称; aij : 为该实体的一个方面 (诺基亚电池不错，电池为该方面) ; sijkl : 值对实体某个方面的意见，如上面所举的例子，不错为对诺基亚电池的意见; hk : 为发表意见的人或者部门 (holder) ; tl : 为发表该意见的时间; 为了获取这五部分需要进行六个任务，在任务之前需要解释一下所用到的概念： 实体模型 ( Model of entity ): 一个实体或目标 ei 是有一组 aspects 的集合组成 A = { ai1, ai2, &hellip;, ain }. ei 可以由其实体表达式的任一的有限集合来表示 { eei1, eei2, &hellip;, eeis }. 每个实体中的 aspects aij ∈ Ai 可以被其 aspect (方面) 表达式的任一有限集合来表示 { aeij1, aeij2, &hellip;, aeijm }. 文本意见模型 ( Model of opinion document ): 一个意见文档 d 包含在某一个时间点上意见持有者集合 { h1, h2, &hellip;, hp} 对实体集合 { e1, e2, &hellip;, ei } 的一些方面 ( aspects ) 所发表的意见。 所以，给定一个意见文档D，意见分析包含以下6个任务： Task 1 实体提取与分类 ( Entity extraction and categorization): 提取D中的所有实体表达式，并将同义实体表达式分类或分组到实体集群（或类别）中。 每个实体表达式集合指示唯一实体 ei ; Task 2 方面(属性)提取与分类 ( aspect extraction and categorization): 提取实体的所有方面 ( aspect ) 表达式，并将这些方面表达式分类到集中。 实体 ei 的每个方面表达式集表示唯一的方面 aij ; Task 3 意见持有者(发布者)提取与分类 ( opinion holder extraction and categorization): 从文本或结构化数据中提取意见持有人的意见，并对其进行分类; Task 4 时间提取与分类 ( time extraction and categorization): 提取意见的时间，标准化不同的时间格式; Task 5 对属性情绪分类 ( aspect sentiment classification ): 确定关于方面 aij 的意见是正面的，负面的还是中性的，或者将方面的数字情感评级分配; Task 6 五元意见组的生成 ( opinion quintuple genertation ): 基于上述任务的结果生成在文档d中表达的所有意见五元组 ( ei, aij, sijkl, hk, tl ) ; 通常把基于该框架的意见分析叫做基于 aspect 的情感分析 ( aspect-based sentiment analysis )。 Aspect-level这里主要集中讨论上述六个任务中的方面(属性)提取与分类 ( aspect extraction and categorization) 任务： 方面提取 ( Aspect extraction ): 例如 “The voice quality of this phone is amazing,” 其中 ”voice quality“ 是 ”This phone“ 的方面，但是 ”This phone“ 并不指明是一个 GENRAL 的方面，因为在这里他只是代表了电话的 voice quality. 但是 ”I love this phone“ 指明了电话代表了一个全体。所以 GENRAL 方面为 ”This phone“. 记住每当我们谈论一个方面时，我们必须知道它属于哪个实体。 方面分类 ( Asepect Sentiment classfication ): 这个任务决定了不同方面的观点是积极，消极还是中立。 在上面的第一个例子中，对 “voice quality” 方面的意见是积极的。 在第二个例子中，对 GENERAL 方面的意见也是积极的。 方面情感分类( Aspect Sentiment Classification )在进行分类时主要有两种方法： 基于监督学习的方法 基于词典的方法 基于监督学习的方法：当前的主要进行的方法是分析确定依赖关系，比如: ( Jiang et al..2011 ) 将一组方面的相关特征进行分类 ( Boiy and Moens, 2009 ) 基于解析树中对目标的方面特征的位置进行加权分析 基于监督学习的方法依赖于训练数据，这表明从一个领域标记的训练数据训练出来的模型在另一个领域中表现很差。并且当前的方法研究也主要应用于文档级别，因为文档级别较长，并且包含比单个句子更多的分类特征。因此，监督学习难以扩展到大量的应用领域。 基于词典的方法：该方法可以避免一些基于监督学习所遇到的问题，并且已经证明在大量领域表现不错。这样的方法通常为无监督的，通过应用情感词典 ( sentiment lexicon ) , 复合表达 ( composite expressions ) , 意见规则 ( role of opinion ) 和 句子解析树来确定句子中每个方面的情感趋向。同时也考虑了情感转意 ( sentiment shifters ) , 转折词 ( but-clauses ) 等。 下面介绍一个简单的基于词典的方法分类方法，假设实体和方面已知，其主要有四个步骤： 标记情感词和情感短语 ( Mark Sentiment words and phrases ) : 标记句子中的情感词和短语，每个积极的情感给情感分数+1，每个校级的情感给情感分数-1，例如：”The voice quality of this phone is not good, but the battery life is long.“ 通过分析时候，该句子变成 ”The voice quality of this phone is not good [+1], but the battery life is long“ 因为 ”good“ 是一个积极的词语，但是注意 “long” 并不是一个情感词，并且也不指明情感的积极和消极态度，但是联系上下文可知 ”long“ 可以代表一个情感词。 应用情感转意 ( Apply sentiment shifters ) 情感转义 ( Sentiment shifters ) 是词或者短语，它可以改变情感的方向，这里有很多转换，例如有可能转换语义的消极词语：*not, never, none, nobody, nowhere, neither, cannot*，通过该分析，由于句子中存在 ”not“ 所以该句子变成 ”The voice quality of this phone is not **good* [-1], but the *battery life\* is long“* 注意，并不是所有这些词语会让情感转变，比如 ”not only… but also.“ 遇到这些词需要我们注意。 处理转折词(Handle but-clauses) : 表示相反的词或短语需要特殊处理，因为它们也经常改变情绪的方向，在英语中最常使用的反向词为 ”but“ 。 通过应用以下规则来处理包含相反词或短语的句子：如果不能确定一方的意见，则在相反词之前的情感方向和相反词之后的情绪方向彼此相反。使用如果不能确定是因为转折词或短语并不总只是指意见的变化，比如： ”Car-x is great, but Car-y is better.“ 。上述例句因为有转折词 “but” 所以通过这一处理之后上述例句变为： ”The voice quality of this phone is not good [-1], but the battery life is long [+1]“ 。我们可以推断 “long” 对 ”battery life“ 是积极地情感。除了 ”but“ 之外，短语比如: ”with the expection of“, “expect that”, “expect for” 对这些短语的处理方式也是相同的。但是在否定的情况下不是所有的都代表着相反，比如： ” not only… but also. “ 所以处理这些词或短语要预先标识。 总的意见 ( Aggregate opinions ) : 通过意见聚合函数将收集到的情感分数进行处理，从而确定句子中的每个方面上的情感最终取向。其主要步骤为下：&emsp;&emsp;S : 表示一个包含一个方面 ( aspect )集合 { ai1, ai2, &hellip;, ain } 和包含一些情感词或短语的集合 { sw1, sw2, &hellip;, swn } 并且这些情感词或短语通过1-3的步骤得出情感分数的句子。所以意见聚合公式可以表示为：$$score(a_1,s)=\sum_{ow_j∈s}\frac{sw_j.so}{dist(sw_j,a_i)}$$&emsp;&emsp;swj : 是句子中的情感词或短语。&emsp;&emsp;dist( swj, ai) : 是方面ai 与情感词 swj 在 s 中的距离。&emsp;&emsp;dist( swj, ai) : 是方面ai 与情感词 swj.so 为 swi 的情感词分数。 如果最终得分是正的，那么对方面 ai 的意见是肯定的。如果最终得分为负，则情绪为负，否则为中性。这种方法在很多情况下表现良好。 同时，现在有很多其他意见聚合函数方法，比如： ( Hu and Liu, 2004 ) 简单地总结句子或句子段中的所有情绪词的情绪分数。 ( Kim and Hovy, 2004 ) 使用词的情绪分数相乘的办法。 意见基本规则和语义的组成 ( Basic Rules of Opinions and Compositional Semantics )意见规则表达了一种暗示正面或负面情绪的概念。它可以是简单的个人情绪词与他们的隐含情绪或复合表达式，可能需要常识或领域知识来确定他们的方向。下面将描述这些规则。表示这些规则的一种方式是使用组合语义 ( compositional semantics ) 的概念，其中陈述了复合表达式的含义是其组成部分的含义和它们组合的语法规则的函数。下面，我们首先在概念层次上描述规则，而不考虑它们如何在实际句子中表达，因为许多这些规则可以以多种方式表达，并且也可以是和上下文相关的。之后，我们转到表达式层次，讨论在情感分析的上下文中关于组成语义的当前研究，其目的是组合多个输入成分表达式以导出复合表达式的整体情绪方向。规则使用类似于 BNF 形式的方式表示，其规则表如下： 1. POSITIVE &emsp;&emsp; ::= P2. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| PO3. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| sentiment_shifter N4. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| sentiment_shifter NE5. NEGATIVE&emsp;&emsp;::= N6. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| NE7. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| sentiment_shifter P8. &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| sentiment_shifter PO P 和 PO 为两种积极的情感表达式，其中： P 为原子表达式，即为句子或短语。 PO 为多个表达式组成的表达式。 N 和 NE 为两种消极的情感表达式，其中： N 为原子表达式，即为句子或短语。 NE 为多个表达式组成的表达式。 “sentiment_shifter P” 和 ”sentiment_shifter PO“* 代表的消极的积极态度。即为消极态度。 “sentiment_shifter N” 和 ”sentiment_shifter NE“* 代表的消极的消极态度。即为积极态度。 需要注意的是，这些不是以实际的BNF形式表示，而是用伪语言表示的抽象概念。我们很难精确的指出这些情感，因为在情感转意 ( sentimet_shifters ) 中会转到不同的情感方向，最后的 POSITIVE 和 NEGATIVE 表示最后的分析结果。 情感转意( sentimet_shifters ): 消极词语例如：*not, never, none, nobody, nowhere, neither, cannot* 是最常见的情感转意词语，同时情态动词 ( Modal auxiliary verbs ) 例如 *would, should, could, might, must, ought* 是一种转意词语，例如：”The brake could be improved,“ 可以转意情感，但并不是所有的是这样。有一些前缀词语也是一方面。一些典型的副词例如 ”barely“, “hardly”\ 通过比较 ”It works“ 和 “It hardly works” 可知两个反面意见是不同的。同时想一些 ”fail“, “omit”, “neglect” 同样具有转意功能。讽刺句\ *( sarcasm )\* 也会改变句子的情感方向。虽然手动识别这样的转意不是困难的，但是通过自动化系统识别它们并在实际句子中正确地处理它们是具有挑战性的。 现在定义不包含转意的 N, NE, P, PO 基于他们的特性将这些表达式分组成六个概念类别： 情感词或短语 ( Sentiment word and phrase ) : 这是最简单的也是最常用的类别，其中情绪词或短语单独可以暗示方面 ( aspect ) 的正面或负面意见，例如 “The voice quality is good” 中的 “good” 。这些词语或短语被称为为 P 和 N. 9. P &emsp;&emsp; ::= a_positive_sentiment_word_or_phrase10. N &emsp;&emsp; ::= a_negative_sentiment_word_or_phrase 积极或消极意见项目的减少或增加 ( Decreased and increased quantity of an opinionated item (N and P) ) : 表示减少或增加与意见项目（通常名词和名词短语）相关联的数量可以改变情感的方向。比如: ”This drug reduced my pain significantly“. ”drug” 是一个消极的词语，而 ”reduced pain“ 则表示减少疼痛是一个积极的方向。 11. PO &emsp;&emsp; ::= less_or_decreased N12. N &emsp;&emsp;&emsp;::= more_or_increased P13. NE &emsp;&emsp; ::= less_or_decreased P14. N &emsp;&emsp;&emsp;::= more_or_increased N 在潜在的消极或积极条目中增加或减少 ( High, low, increased and decreased quantity of a positive or negative potential item ) : 例如：“The battery life is short” 和 “The battery life is long.” 这些方面比如 ”battery life“ 的 态度是积极的，我们称他们为 PPI *( positive potential items )*. 同理，例如: “This phone costs a lot” 和 “Sony reduced the price of the camera.” 其中 ”Cost“ 和 ”price“ 的态度是消极的，我们称他们为 NPI *( negative potential items )* 诸如 ”battery“, ”cost“, “price” 本身并没有情感方向，但是增加量词之后就有了方向，其可表示为下面中的规则。 15. PO &emsp;&emsp; ::= no_low_less_or_decreased_quantity_of NPI16. &emsp;&emsp;&emsp;&emsp; | large_larger_or_increased_quantity_of PPI17. NE &emsp;&emsp; ::= no_low_less_or_decreased_quantity_of PPI18. &emsp;&emsp;&emsp;&emsp; | large_larger_or_increased_quantity_of NPI19. NPI &emsp;&emsp; ::= a_negative_potential_item20. PPI &emsp;&emsp;::= a_positive_potential_item 可取或不可取的事实( Desirable or undesirable fact ) : 客观表达式可能意味着积极或消极的情绪，因为他们可以描述可取和不可取的事实。例如：”After my wife and I slept on the mattress for two weeks, I saw a mountain in the middle”. 该句话清楚地隐含了对 ”mattress“ 的消极情绪，但是 ”mountain“ 并没有携带任何意见，因此遵循下面两个规则: 21. P &emsp;&emsp; ::= desirable_fact22. N &emsp;&emsp;::= a_positive_potential_item 与规范或期望值范围的偏差( Deviation from the norm or a desired value range ) : 在一些应用程序领域中，项目的值具有期望的范围或范数，如果该值偏离正常范围，则为消极的，例如: “After taking the drug, my blood pressure went to 410.” 通常这样句子为客观的，所以定义如下规则。 23. P &emsp;&emsp; ::= within the_desired_value_range24. N &emsp;&emsp;::= deviate_from the_desired_value_range 生产、消耗、浪费资源或废物 ( Produce and consume resource and waste ) : 如果实体产生大量的资源，则是期望的（积极的），若是消耗大量资源，则是不被期望的（消极的），同理如果生产大量废物则是不被期望的（消极的），同理如果消耗大量废物则是期望的（积极的），所以定义如下规则。 25. P &emsp;&emsp; ::= produce a_large_quantity_of_or_more resource26. &emsp;&emsp;&emsp; | produce no,_little_or_less waste27. &emsp;&emsp;&emsp; | consume no,_little_or_less resource28. &emsp;&emsp;&emsp; | consume a_large_quantity_of_or_more waste29. N &emsp;&emsp; ::= produce no,_little_or_less resource30. &emsp;&emsp;&emsp; | produce some_or_more waste31. &emsp;&emsp;&emsp; | consume a_large_quantity_of_or_more resource32. &emsp;&emsp;&emsp; | consume no,_little_or_less waste 这些概念规则可以在实际句子中使用不同的单词和短语出现在许多（看似无限数量）的形式中，并且在不同的领域中，它们也可以以不同的方式表现。因此，他们很难认识。没有认识他们，规则不能应用。 现在研究最多的组成规则是与情绪逆转 ( sentimet reversal ) 有关，通常有情感转意和消极积极词语组成，比如: ”NOT“ &amp; POS(“good”) => NEG(“not good”)，另一方面就是遵循11到14的规则，比如：”reduced“ &amp; NEG(“PAIN”) => POS(“reduced pain”)。还有就是情感冲突( sentiment conflict ), 当多个情感词汇出现在一起时，例如 “terribly good” 冲突解决是通过基于分配给它们的相对权重对成分进行排序来实现的，这些相对权重指示哪些成分对于情绪更重要。10年，引入了六种类型的组合规则，他们是情绪反转 (sentiment reversal)，聚集 (aggregation)，传播 (propagation), 控制 (domination), 中和 (neutralization), 集中 (intensification)。其分别表示如下： 情绪反转 (sentiment reversal): 和之前说明的规则类似。 聚集 (aggregation): 与情绪冲突(sentiment conflict)相似，但是定义不同，如果形容词-名词，副词-形容词，副词-动词短语中的术语的情感具有相反的方向，则将具有预修饰符的主导极性的混合极性分配给短语。比如，POS(“beautiful”) &amp; NEG(“fight”) => POSneg(“beautiful fight”)。 传播 (propagation): 当在短语/子句中使用 “propagation” 或 “transfer” 类型的动词时，应用传播规则，并且需要确定具有之前方面的极性。比如，PROP-POS(“to admire”) &amp; “his behavior” => POS(“his behavior”); “Mr.X” &amp; TRANS(“supports”) &amp; NEG(“crime business”) => NEG(“Mr.X”)。 控制 (domination): (1) 如果子句中的动词和客观的极性具有相反的方向，则动词的极性占优势，比如，NEG(“to deceive”) &amp; POS(“hopes”) => NEG(“to deceive hopes”).(2) 如果一个复合句使用 but 连接，则 but 后面的子句的态势特征是占主导地位，比如，”NEG(“It was hard to climb a mountain all night long”), but POS(“a magnificent view rewarded the traveler at the morning”).“ => POS(whole sentence)). 中和 (neutralization): 当介词修饰符或条件运算符与情绪语句相关时，应用中和规则，比如，“despite” &amp; NEG(‘worries’) => NEUT(“despite worries”). 集中 (intensification): 加强或者削弱情感分数，比如，Pos_score(“happy”) \&lt; Pos_score(“extremely happy”)). 方面提取( Aspect Extraction )该任务可以看做是一个信息提取任务，但是，在情感分析的上下文中，一些问题的具体特征可以方便进行提取。这个关键特征就目标的意见，而目标通常是从句子中提取的方面或者主题。因此，重要的任务是从句子识别目标并且识别其表达的意见。但是意见分为显示意见和隐示意见，显示意见的提取主要有以下四个方面： 基于频繁名词和名词短语的提取 利用意见和目标关系提取 利用监督学习提取 利用主题模型提取 由于方面提取主要形式是在线评论，其有两种文本格式，如下： My SLR is on the shelf by camerafun4 Aug 09’04 Pros: Great photos, easy to use, very small Cons: Battery usage; included memory is stingy. I had never used a digital camera prior to purchasing this Canon A70. I have always used a SLR … Read the full review Figure 5.1. An example of a review of format 1. GREAT Camera., Jun3,2004 Reviewer: jprice174 from Atlanta, Ga Aug 09’04 Pros: Great photos, easy to use, very small Cons: Battery usage; included memory is stingy. I did a lot of research last year before I bought this camera… It kinda hurt to leave behind my beloved nikon 35mm SLR, but I was going to Italy, and I needed something smaller, and digital. The pictures coming out of this camera are amazing. The ‘auto’ feature takes great pictures most of the time. And with digital, you’re not wasting film if the picture doesn’t come out. … Figure 5.2. An example of a review of format 2. 查找频繁名词和名词短语该方法从给定领域中的大量评论中找到作为名词和名词短语的显式方面表达式。其方法有： (Hu and Liu, 2004) 使用数据挖掘算法，用磁性 (POS) 标识器识别名词和名词短语（或组）。 该方法的主要思想是：记录他们出现的频率，并且仅保留频繁的频率，其中频率阈值可以通过实验确定。使用这种方法的原因是，当人们评论一个实体的不同方面时，他们使用的词汇通常收敛。因此，经常谈论的那些名词通常是真实和重要的方面。但是评论中的不相关内容通常是多样的，即，在不同的评论中它们是非常不同的。因此，这些不频繁的名词可能是非方面或较不重要的方面。虽然这种方法很简单，但实际上是相当有效的。 这种算法的精度被(Popescu and Etzioni,2005)提高了，他们的算法试图去除那些可能不是实体方面的名词短语，它通过计算短语和与实体类相关联的一些关系区分器 (mernoymy discriminators) 例如（camera）之间的点向互信息（PMI）得分来评估每个发现的名词短语。通过搜索网络用于找到 camera 的组件或部分得出的 camera 的名关系区分器为 “of camera”, “camera has”, “camera comes with” 等。其 PMI 的简化公式为：$$PMI(a,d)=\frac{hits(a ∩ d)}{hits(a)hits(d)}$$其中: a 为使用频率识别出来的候选的方面 (aspect) d 为一个鉴别器 使用方面 (aspect) 识别资源在许多应用中，资源使用是重要的方面，例如，“This washer uses a lot of water.”。在这里，对 ”water“ 的使用量是 ”washer“ 的一个方面，并且这句话指示消极意见，因为消耗太多的资源是不期望的。但是这句话中没有意见，因此，发现资源词和短语（其被称为资源术语）对于情感分析是重要的。如下，显示了之前提出的两个涉及资源的意见规则： P&emsp;&emsp;&emsp; | consume no,_little_or_less resource N&emsp;&emsp;&emsp; | consume a_large_quantity_of_or_more resource 在（Zhang和Liu，2011a）中，提出了一种提取资源项的方法。 例如，在上述示例中，应当提取 “water” 作为资源项。该方法基于二分图拟定了问题，并提出了一种迭代算法来解决这个问题。 该算法基于以下观察提出： 在句子中表达的关于资源使用的情绪或观点通常由以下三元组确定，{动词(verb), 量词(quantifier), 名词或名词词组(noun_term)}. 例如：”This washer uses a lot of water“, 中 ”uses“ 是动词，”a lot of“, 是量词，”water“, 为名词代表着资源。 该方法使用这样的三元组来帮助识别域语料库中的资源。该模型使用基于二分图循环定义来反映的资源使用动词（例如，consume）和资源术语（例如，water）之间的特殊强化关系。量词不用于计算，而是用于识别候选动词和资源术语。该算法假定给出了一个量不多并且可以手动编译的量化器列表。基于循环定义，使用类似于 HITS 的迭代算法来解决问题。为了开始迭代计算，使用一些全局种子资源来寻找和得出使用资源较强的动词的得分。然后将这些分数应用为用于任何应用域的迭代计算的初始化。当算法收敛时，就识别出了候选资源项的排序列表。 意见词典扩展和方面提取由于情绪/观点与其目标（或方面）之间的关系，情感词可以通过所识别的方面来识别，并且方面可以通过已知的情绪词来识别。提取的情感词和方面被用于识别新的情感词和新的方面，其被再次用于提取更多的情感词和方面。由于该过程涉及通过情感词和方面的传播，该方法被称为双重传播(double propagation)。这些提取规则基于基于情感词和方面之间的某些特定依赖关系。采用依赖语法来描述关系。同时也强加了一些限制，情感词也可被认为是形容词和方面名词或名词短语。情感词和方面之间的依赖关系包括 mod, pnmod, subj, s, obj, obj2和desc, 而情感词和方面本身只包含连接关系conj。 OA-Rel 表示情感词和方面之间的关系，情感词本身之间的联系 OO-Rel 和方面之间的联系 AA-Rel,而每个 OA-Rel，OO-Rel或AA-Rel中的关系是&lt; POS(wi), R,POS(wj)&gt;的三元组, 其中POS(wi)是词wi的POS标签，R是依赖关系。该提取过程是基于规则的方法，比如：”Canon G3 produces great pictures,” 形容词 “great” 通过 mod 解析认为依赖于名词 “picture” 这种形式形成 OA-Rel. 类似于这样，如果我们知道 “great” 是一个情感词，并且给出一个规则 “一个情感词通过 mod 依赖于一个名词，则名词可以作为一个方面”，通过这个规则可以直接提取 “picture” 作为一个方面 (aspect). 同理，我们知道 “picture” 是一个方面，则可以利用类似的规则提取 “great” 作为情感词。通过这种方式有以下四个任务： 利用情感词提取方面 利用方面提取方面 利用提取的方面提取情感词 使用给定和提取的意见词提取情感词其中 OA-Rels 被用来给任务 1 和 3，AA-Rels 被用作任务 2 ，OO-Rels 被用作任务 4。这四个子任务分别定义了四类型规则,如下图表中所示： 表中 o 或者 a 为要提取的情感词或方面 (aspect)，{O} 或者 {A} 是给定或提取的已知的情绪词或方面的集合。H 代表任意单词，POS(O(or A))和 O(or A)-Dep 代表着 POS 标签和单词 O(or A) 的依赖关系。{JJ} 和 {NN} 分别是潜在的情感词和方面的 POS 标签集合。{JJ} 包含 JJ, JJR, JJS; {NN} 包含 NN 和 NNS; {MR} 由依赖关系组成，包含{mod, pnmod, subj, s, obj, obj2, desc}; {CONJ} 只包含 conj, 箭头表示依赖，例如：O → O-Dep → A 代表 O 通过关系 O- Dep 依赖于 A. 具体来说，R1i 为使用情感词 (O) 来提取方面 (a)，R2i 为使用方面 (A) 来提取情感词 (O)，R3i 为使用提取出来的方面集合 (Ai) 来提取方面 (a)，R4i 为使用提取出来的情感词集合 (Oi) 来提取情感词 (o). 该表中的方法最初是为英语设计，但是也适用于中文在线文本讨论，这种方法也可以仅使用一个情感词典来查找方面。 总结该文章为通过自己翻译 基于 Aspect 的情感分析 的这一章的部分内容理解而总结，也是自己对看过内容之后的记录，谢谢！]]></content>
    </entry>

    
  
  
</search>
